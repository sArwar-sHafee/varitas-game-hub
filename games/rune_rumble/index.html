<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rune Rumble - Gesture Action Game</title>
    <style>
        :root {
            --primary: #00f2ff;
            --secondary: #ff0055;
            --bg: #0f0c29;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #0f0c29, #302b63, #24243e);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 242, 255, 0.8);
        }

        .health-bar-container {
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
        }

        #health-bar-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0055, #ff5e00);
            transition: width 0.2s;
        }

        #screens {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(5px);
            z-index: 10;
            transition: opacity 0.3s;
        }

        .screen {
            text-align: center;
            display: none;
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .screen.active {
            display: block;
        }

        h1 {
            font-size: 60px;
            margin: 0 0 20px 0;
            background: linear-gradient(to right, #00f2ff, #ff0055);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            filter: drop-shadow(0 0 15px rgba(255,255,255,0.3));
        }

        p {
            font-size: 20px;
            color: #ddd;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        .rune-guide {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .rune-card {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .rune-symbol {
            font-size: 30px;
            color: var(--primary);
            display: block;
            margin-bottom: 5px;
        }

        button {
            background: linear-gradient(45deg, #00f2ff, #008cff);
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            color: white;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.5);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 242, 255, 0.8);
        }

        button:active {
            transform: scale(0.95);
        }

        @keyframes popIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .damage-flash {
            animation: flashRed 0.2s;
        }

        @keyframes flashRed {
            0% { background-color: rgba(255, 0, 0, 0.3); }
            100% { background-color: transparent; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud">
            <div>SCORE: <span id="score-display">0</span></div>
            <div class="health-bar-container">
                <div id="health-bar-fill"></div>
            </div>
        </div>
    </div>

    <div id="screens">
        <!-- Start Screen -->
        <div id="start-screen" class="screen active">
            <h1>RUNE RUMBLE</h1>
            <p>Defend the realm from falling chaos!</p>
            <div class="rune-guide">
                <div class="rune-card"><span class="rune-symbol">─</span>Horizontal</div>
                <div class="rune-card"><span class="rune-symbol">│</span>Vertical</div>
                <div class="rune-card"><span class="rune-symbol">v</span>V-Shape</div>
                <div class="rune-card"><span class="rune-symbol">^</span>Caret</div>
            </div>
            <p>Draw the shapes on screen to destroy enemies.</p>
            <button id="btn-start">PLAY GAME</button>
        </div>

        <!-- Game Over Screen -->
        <div id="gameover-screen" class="screen">
            <h1>GAME OVER</h1>
            <p>The chaos consumed you.</p>
            <p>Final Score: <span id="final-score">0</span></p>
            <button id="btn-restart">TRY AGAIN</button>
        </div>
    </div>

<script>
/**
 * AUDIO SYSTEM
 */
class AudioSys {
    constructor() {
        this.ctx = null;
        this.masterGain = null;
    }

    init() {
        if (!this.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.3;
            this.masterGain.connect(this.ctx.destination);
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    playTone(freq, type, duration, vol = 1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.masterGain);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playShoot() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1200, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.2);
    }

    playExplosion() {
        this.playTone(100, 'sawtooth', 0.3, 0.8);
        this.playTone(50, 'square', 0.4, 0.8);
    }

    playDamage() {
        this.playTone(150, 'sawtooth', 0.5, 1.0);
        this.playTone(100, 'sawtooth', 0.5, 1.0);
    }

    playDraw() {
        if (!this.ctx) return;
        if (Math.random() > 0.5) return; 
        this.playTone(Math.random() * 200 + 400, 'triangle', 0.1, 0.1);
    }
}

/**
 * GESTURE RECOGNIZER
 */
const GESTURES = {
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical',
    V_SHAPE: 'v_shape',
    CARET: 'caret',
    UNKNOWN: 'unknown'
};

class Recognizer {
    constructor() {
        this.minDist = 30; 
    }

    analyze(points) {
        if (points.length < 5) return GESTURES.UNKNOWN;

        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        points.forEach(p => {
            if (p.x < minX) minX = p.x;
            if (p.x > maxX) maxX = p.x;
            if (p.y < minY) minY = p.y;
            if (p.y > maxY) maxY = p.y;
        });

        const width = maxX - minX;
        const height = maxY - minY;

        if (width > height * 2.5 && width > this.minDist) {
            return GESTURES.HORIZONTAL;
        }

        if (height > width * 2.5 && height > this.minDist) {
            return GESTURES.VERTICAL;
        }

        let lowestY = Infinity;
        let highestY = -Infinity;
        let lowestIndex = 0;
        let highestIndex = 0;

        for(let i=0; i<points.length; i++) {
            if (points[i].y < lowestY) { lowestY = points[i].y; lowestIndex = i; }
            if (points[i].y > highestY) { highestY = points[i].y; highestIndex = i; }
        }

        const first = points[0];
        const last = points[points.length - 1];

        // V-Shape: Pointy part is at the bottom (highest Y value)
        if (highestIndex > points.length * 0.2 && highestIndex < points.length * 0.8) {
            if (first.y < highestY - height * 0.5 && last.y < highestY - height * 0.5) {
                return GESTURES.V_SHAPE;
            }
        }

        // Caret: Pointy part is at the top (lowest Y value)
        if (lowestIndex > points.length * 0.2 && lowestIndex < points.length * 0.8) {
            if (first.y > lowestY + height * 0.5 && last.y > lowestY + height * 0.5) {
                return GESTURES.CARET;
            }
        }

        return GESTURES.UNKNOWN;
    }
}

/**
 * GAME CLASSES
 */
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 3 + 1;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.decay = Math.random() * 0.03 + 0.02;
        this.color = color;
        this.size = Math.random() * 3 + 2;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
        this.size *= 0.95;
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Enemy {
    constructor(w, h, difficulty) {
        this.radius = 25;
        this.x = Math.random() * (w - 100) + 50;
        this.y = -50;
        this.speed = (Math.random() * 1 + 0.5) + (difficulty * 0.1);
        this.color = `hsl(${Math.random()*60 + 300}, 100%, 50%)`;
        
        const types = [GESTURES.HORIZONTAL, GESTURES.VERTICAL, GESTURES.V_SHAPE, GESTURES.CARET];
        this.type = types[Math.floor(Math.random() * types.length)];
    }

    update() {
        this.y += this.speed;
    }

    draw(ctx) {
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = "#fff";
        ctx.font = "bold 24px monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        let symbol = "?";
        switch(this.type) {
            case GESTURES.HORIZONTAL: symbol = "─"; break;
            case GESTURES.VERTICAL: symbol = "│"; break;
            case GESTURES.V_SHAPE: symbol = "v"; break;
            case GESTURES.CARET: symbol = "^"; break;
        }
        
        ctx.fillText(symbol, this.x, this.y - 40);

        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(this.x - 8, this.y - 5, 3, 0, Math.PI*2);
        ctx.arc(this.x + 8, this.y - 5, 3, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.x, this.y + 8, 4, 0, Math.PI, false);
        ctx.stroke();
    }
}

class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.targetAngle = -Math.PI / 2;
        this.angle = -Math.PI / 2;
    }

    update(targetX, targetY) {
        if (targetX !== null) {
            this.targetAngle = Math.atan2(targetY - this.y, targetX - this.x);
        } else {
            this.targetAngle = -Math.PI / 2;
        }
        // Simple easing
        let diff = this.targetAngle - this.angle;
        // Normalize angle
        while (diff < -Math.PI) diff += Math.PI * 2;
        while (diff > Math.PI) diff -= Math.PI * 2;
        
        this.angle += diff * 0.1;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.PI/2);

        ctx.shadowBlur = 20;
        ctx.shadowColor = "#00f2ff";
        ctx.fillStyle = "#fff";
        
        ctx.beginPath();
        ctx.moveTo(0, -20);
        ctx.lineTo(-15, 20);
        ctx.lineTo(15, 20);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#00f2ff";
        ctx.beginPath();
        ctx.arc(0, -20, 8, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }
}

/**
 * MAIN GAME ENGINE
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.audio = new AudioSys();
        this.recognizer = new Recognizer();
        
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        
        this.state = 'start'; // start, playing, gameover
        this.score = 0;
        this.health = 100;
        this.difficulty = 1;

        this.player = null;
        this.enemies = [];
        this.particles = [];
        
        this.isDrawing = false;
        this.currentStroke = [];
        this.trailPoints = [];

        this.lastSpawnTime = 0;
        this.spawnRate = 2000;

        this.bindEvents();
        this.resize();
        
        this.lastTime = 0;
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        if (this.player) {
            this.player.x = this.width / 2;
            this.player.y = this.height - 60;
        } else {
            this.player = new Player(this.width / 2, this.height - 60);
        }
    }

    bindEvents() {
        window.addEventListener('resize', () => this.resize());

        const startDraw = (e) => {
            if (this.state !== 'playing') return;
            this.isDrawing = true;
            this.currentStroke = [];
            const pos = this.getPos(e);
            this.currentStroke.push(pos);
            this.trailPoints = [pos];
        };

        const moveDraw = (e) => {
            if (!this.isDrawing || this.state !== 'playing') return;
            const pos = this.getPos(e);
            
            const last = this.currentStroke[this.currentStroke.length-1];
            const dist = Math.hypot(pos.x - last.x, pos.y - last.y);
            
            if (dist > 5) {
                this.currentStroke.push(pos);
                this.audio.playDraw();
            }
            this.trailPoints.push(pos);
            
            if (this.trailPoints.length > 50) this.trailPoints.shift();
        };

        const endDraw = () => {
            if (!this.isDrawing) return;
            this.isDrawing = false;
            this.processGesture();
        };

        this.canvas.addEventListener('mousedown', startDraw);
        this.canvas.addEventListener('mousemove', moveDraw);
        window.addEventListener('mouseup', endDraw);

        this.canvas.addEventListener('touchstart', (e) => { 
            if(e.cancelable) e.preventDefault(); 
            startDraw(e.touches[0]); 
        }, {passive: false});
        this.canvas.addEventListener('touchmove', (e) => { 
            if(e.cancelable) e.preventDefault(); 
            moveDraw(e.touches[0]); 
        }, {passive: false});
        window.addEventListener('touchend', endDraw);

        document.getElementById('btn-start').addEventListener('click', () => {
            this.audio.init();
            this.startGame();
        });
        document.getElementById('btn-restart').addEventListener('click', () => {
            this.startGame();
        });
    }

    getPos(e) {
        const rect = this.canvas.getBoundingClientRect();
        return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
    }

    startGame() {
        this.state = 'playing';
        this.score = 0;
        this.health = 100;
        this.difficulty = 1;
        this.spawnRate = 2000;
        this.enemies = [];
        this.particles = [];
        this.currentStroke = [];
        this.trailPoints = [];
        this.lastSpawnTime = performance.now();
        
        document.getElementById('start-screen').classList.remove('active');
        document.getElementById('gameover-screen').classList.remove('active');
        document.getElementById('screens').style.display = 'none';
        
        this.updateUI();
    }

    gameOver() {
        this.state = 'gameover';
        this.audio.playExplosion();
        document.getElementById('screens').style.display = 'flex';
        document.getElementById('gameover-screen').classList.add('active');
        document.getElementById('final-score').innerText = this.score;
    }

    processGesture() {
        const gesture = this.recognizer.analyze(this.currentStroke);
        
        if (gesture !== GESTURES.UNKNOWN) {
            let target = null;
            let maxVal = -Infinity;

            const candidates = this.enemies.filter(e => e.type === gesture && e.y < this.height - 100);
            
            candidates.forEach(e => {
                if (e.y > maxVal) {
                    maxVal = e.y;
                    target = e;
                }
            });

            if (target) {
                this.destroyEnemy(target);
            }
        }
        
        this.currentStroke = [];
    }

    destroyEnemy(enemy) {
        this.audio.playShoot();
        setTimeout(() => this.audio.playExplosion(), 100);

        this.createBeam(this.player.x, this.player.y, enemy.x, enemy.y);

        for(let i=0; i<15; i++) {
            this.particles.push(new Particle(enemy.x, enemy.y, enemy.color));
        }

        const idx = this.enemies.indexOf(enemy);
        if (idx > -1) this.enemies.splice(idx, 1);

        this.score += 10;
        
        if (this.score % 50 === 0) {
            this.difficulty++;
            this.spawnRate = Math.max(500, 2000 - (this.difficulty * 100));
        }
        
        this.updateUI();
    }

    createBeam(x1, y1, x2, y2) {
        const dist = Math.hypot(x2-x1, y2-y1);
        const steps = dist / 10;
        for(let i=0; i<steps; i++) {
            const t = i/steps;
            const px = x1 + (x2-x1)*t;
            const py = y1 + (y2-y1)*t;
            const p = new Particle(px, py, "#00f2ff");
            p.vx = (Math.random()-0.5)*2;
            p.vy = (Math.random()-0.5)*2;
            p.life = 0.5;
            this.particles.push(p);
        }
    }

    takeDamage() {
        this.health -= 10;
        this.audio.playDamage();
        
        document.body.classList.add('damage-flash');
        setTimeout(() => document.body.classList.remove('damage-flash'), 200);

        if (this.health <= 0) {
            this.health = 0;
            this.gameOver();
        }
        this.updateUI();
    }

    updateUI() {
        document.getElementById('score-display').innerText = this.score;
        document.getElementById('health-bar-fill').style.width = this.health + '%';
    }

    loop(timestamp) {
        const dt = timestamp - this.lastTime;
        this.lastTime = timestamp;

        if (this.state === 'playing') {
            if (timestamp - this.lastSpawnTime > this.spawnRate) {
                this.enemies.push(new Enemy(this.width, this.height, this.difficulty));
                this.lastSpawnTime = timestamp;
            }

            for (let i = this.enemies.length - 1; i >= 0; i--) {
                let e = this.enemies[i];
                e.update();
                
                if (e.y > this.height - 80) {
                    this.takeDamage();
                    this.enemies.splice(i, 1);
                }
            }

            let closest = null;
            let maxY = -Infinity;
            this.enemies.forEach(e => { if(e.y > maxY) { maxY = e.y; closest = e; }});
            if (closest) this.player.update(closest.x, closest.y);
            else this.player.update(null, null);
        }

        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update();
            if (this.particles[i].life <= 0) this.particles.splice(i, 1);
        }

        if (!this.isDrawing && this.trailPoints.length > 0) {
            this.trailPoints.splice(0, 2);
        }

        this.draw();
        requestAnimationFrame(this.loop);
    }

    draw() {
        this.ctx.fillStyle = 'rgba(15, 12, 41, 0.3)';
        this.ctx.fillRect(0, 0, this.width, this.height);

        if (this.player) this.player.draw(this.ctx);
        this.enemies.forEach(e => e.draw(this.ctx));
        this.particles.forEach(p => p.draw(this.ctx));

        if (this.trailPoints.length > 1) {
            this.ctx.beginPath();
            this.ctx.moveTo(this.trailPoints[0].x, this.trailPoints[0].y);
            for (let i = 1; i < this.trailPoints.length; i++) {
                this.ctx.lineTo(this.trailPoints[i].x, this.trailPoints[i].y);
            }
            this.ctx.lineCap = 'round';
            this.ctx.lineJoin = 'round';
            this.ctx.lineWidth = 8;
            this.ctx.strokeStyle = '#00f2ff';
            this.ctx.shadowBlur = 15;
            this.ctx.shadowColor = '#00f2ff';
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
        }
    }
}

window.onload = () => {
    const game = new Game();
};

</script>
</body>
</html>