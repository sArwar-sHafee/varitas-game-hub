<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bounce Draft</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #0c0a18;
            color: #fff;
            overflow: hidden;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            background: #120f28;
            border: 2px solid #4a447c;
        }
        canvas {
            display: block;
            background-color: #1a1636;
        }
        #instructions {
            padding: 10px;
            font-size: 14px;
            color: #ccc;
            text-align: center;
            width: 100%;
            background-color: #1e1a40;
        }
        @media (max-width: 600px) {
            #instructions {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="instructions">
            <strong>Controls:</strong> Arrow Keys / A & D / Drag Mouse or Finger
        </div>
    </div>

    <script>
        // Game inspired by Doodle Jump. All assets are generated procedurally.
        // Created by an AI assistant.

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let W, H;
        let gameState = 'start'; // 'start', 'playing', 'gameOver'
        let score = 0;
        let highScore = localStorage.getItem('bounceDraftHighScore') || 0;
        let cameraY = 0;
        let particles = [];
        let stars = [];

        // --- Game Parameters ---
        const gravity = 0.35;
        const playerMoveSpeed = 7;
        const playerJumpForce = -12;
        const platformHeight = 20;
        const platformWidth = 100;
        const platformSpawnThreshold = 100; // Generate new platforms when player reaches this y-pos from top

        // --- Classes ---
        class Player {
            constructor(x, y) {
                this.width = 45;
                this.height = 45;
                this.x = x - this.width / 2;
                this.y = y - this.height;
                this.vx = 0;
                this.vy = 0;
                this.emoji = 'ðŸ¤ª';
                this.baseEmoji = 'ðŸ¤ª';
                this.jumpEmoji = 'ðŸ˜®';
                this.fallEmoji = 'ðŸ˜µ';
            }

            draw() {
                ctx.font = `${this.height}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x + this.width / 2, this.y + this.height / 2 - cameraY);
            }

            update() {
                // Horizontal Movement
                if (keys['ArrowLeft'] || keys['a']) {
                    this.vx = -playerMoveSpeed;
                } else if (keys['ArrowRight'] || keys['d']) {
                    this.vx = playerMoveSpeed;
                } else if (mouse.isDown) {
                    const targetX = mouse.x - this.width / 2;
                    this.vx = (targetX - this.x) * 0.1;
                } else {
                    this.vx *= 0.85; // Friction
                }

                this.x += this.vx;

                // Screen Wrap
                if (this.x > W) {
                    this.x = -this.width;
                } else if (this.x + this.width < 0) {
                    this.x = W;
                }
                
                // Vertical Movement
                this.vy += gravity;
                this.y += this.vy;

                // Update Emoji
                if (this.vy < -2) this.emoji = this.jumpEmoji;
                else if (this.vy > gravity * 2) this.emoji = this.baseEmoji; // Show base emoji when falling gently
                else this.emoji = this.baseEmoji;
            }

            jump(force = playerJumpForce) {
                this.vy = force;
                playSound('jump');
            }
        }

        class Platform {
            constructor(x, y, isSpecial = false) {
                this.width = platformWidth;
                this.height = platformHeight;
                this.x = x;
                this.y = y;
                this.isSpecial = isSpecial; // Special platforms give a higher bounce
            }

            draw() {
                const screenY = this.y - cameraY;
                let gradient;
                
                if (this.isSpecial) {
                    gradient = ctx.createLinearGradient(this.x, screenY, this.x, screenY + this.height);
                    gradient.addColorStop(0, '#5DADE2');
                    gradient.addColorStop(1, '#2E86C1');
                } else {
                    gradient = ctx.createLinearGradient(this.x, screenY, this.x, screenY + this.height);
                    gradient.addColorStop(0, '#58D68D');
                    gradient.addColorStop(1, '#28B463');
                }
                
                ctx.fillStyle = gradient;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                // Check if roundRect is available, otherwise draw a regular rect
                if (ctx.roundRect) {
                    ctx.roundRect(this.x, screenY, this.width, this.height, [10]);
                } else {
                    ctx.rect(this.x, screenY, this.width, this.height);
                }
                ctx.fill();
                ctx.stroke();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 5 + 2;
                this.vx = (Math.random() - 0.5) * 3;
                this.vy = (Math.random() - 0.5) * 3;
                this.color = color;
                this.life = 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.04;
            }

            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y - cameraY, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // --- Game Objects ---
        let player;
        let platforms = [];

        // --- Controls ---
        const keys = {};
        const mouse = { x: 0, y: 0, isDown: false };

        function setupControls() {
            window.addEventListener('keydown', e => { keys[e.key] = true; });
            window.addEventListener('keyup', e => { keys[e.key] = false; });
            
            canvas.addEventListener('mousedown', () => mouse.isDown = true);
            canvas.addEventListener('mouseup', () => mouse.isDown = false);
            canvas.addEventListener('mouseleave', () => mouse.isDown = false);
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = e.clientX - rect.left;
                mouse.y = e.clientY - rect.top;
            });

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                mouse.isDown = true;
                updateTouch(e);
            }, { passive: false });
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                mouse.isDown = false;
            }, { passive: false });
            canvas.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                mouse.isDown = false;
            }, { passive: false });
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                updateTouch(e);
            }, { passive: false });
            
            function updateTouch(e) {
                const rect = canvas.getBoundingClientRect();
                mouse.x = e.touches[0].clientX - rect.left;
                mouse.y = e.touches[0].clientY - rect.top;
            }
        }
        
        // --- Sound Engine ---
        let audioCtx;
        const soundManager = {
            init() {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn("Web Audio API is not supported in this browser");
                    audioCtx = null;
                }
            },
            play(type) {
                if (!audioCtx) return;
                
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);

                switch(type) {
                    case 'jump':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                        oscillator.frequency.linearRampToValueAtTime(880, audioCtx.currentTime + 0.1);
                        gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.2);
                        break;
                    case 'special_jump':
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(523, audioCtx.currentTime);
                        oscillator.frequency.linearRampToValueAtTime(1046, audioCtx.currentTime + 0.1);
                        gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.3);
                        break;
                    case 'gameOver':
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                        oscillator.frequency.linearRampToValueAtTime(110, audioCtx.currentTime + 0.5);
                        gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.5);
                        break;
                }

                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.5);
            }
        };

        function playSound(type) {
            if (!audioCtx) {
                soundManager.init();
            }
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            soundManager.play(type);
        }

        // --- Game Logic ---
        function init() {
            resizeCanvas();
            setupControls();
            createStars();
        }

        function startGame() {
            cameraY = 0;
            score = 0;
            player = new Player(W / 2, H - 50);
            platforms = [];
            particles = [];

            // Create initial platforms
            platforms.push(new Platform(W / 2 - platformWidth / 2, H - 50));
            for (let i = 0; i < 20; i++) {
                generatePlatform(H - 100 - (i * 100));
            }
            
            gameState = 'playing';
        }

        function generatePlatform(yPos) {
             const x = Math.random() * (W - platformWidth);
             const isSpecial = Math.random() < 0.15; // 15% chance for a special platform
             platforms.push(new Platform(x, yPos, isSpecial));
        }
        
        function createParticles(x, y, color) {
            for (let i = 0; i < 10; i++) {
                particles.push(new Particle(x, y, color));
            }
        }
        
        function createStars() {
            stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    size: Math.random() * 2 + 1,
                    speed: Math.random() * 0.2 + 0.1
                });
            }
        }

        function update() {
            if (gameState !== 'playing') return;

            player.update();

            // Collision with platforms
            if (player.vy > 0) { // only check for collision when falling
                platforms.forEach(p => {
                    if (player.x < p.x + p.width &&
                        player.x + player.width > p.x &&
                        player.y + player.height > p.y &&
                        player.y + player.height < p.y + p.height + player.vy) { // Add player.vy to prevent phasing through
                        
                        if (p.isSpecial) {
                            player.jump(playerJumpForce * 1.8);
                            playSound('special_jump');
                            createParticles(player.x + player.width / 2, p.y, '#5DADE2');
                        } else {
                            player.jump();
                            createParticles(player.x + player.width / 2, p.y, '#58D68D');
                        }
                    }
                });
            }

            // Camera follow
            if (player.y - cameraY < H / 2) {
                cameraY = player.y - H / 2;
            }

            // Update score
            score = Math.max(score, Math.floor(-cameraY / 10));

            // Generate new platforms
            let highestPlatformY = platforms.length > 0 ? Math.min(...platforms.map(p => p.y)) : 0;
            if (highestPlatformY > cameraY - platformSpawnThreshold) {
                generatePlatform(highestPlatformY - (Math.random() * 100 + 80));
            }
            
            // Remove old platforms
            platforms = platforms.filter(p => p.y - cameraY < H + 50);

            // Update particles
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);
            
            // Game Over
            if (player.y - cameraY > H + 50) {
                player.emoji = player.fallEmoji;
                gameState = 'gameOver';
                playSound('gameOver');
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('bounceDraftHighScore', highScore);
                }
            }
        }

        function draw() {
            // Background
            const bgGradient = ctx.createLinearGradient(0, 0, 0, H);
            bgGradient.addColorStop(0, '#1a1636');
            bgGradient.addColorStop(1, '#0c0a18');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, W, H);
            
            // Draw stars with parallax
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            stars.forEach(star => {
                let screenY = (star.y - cameraY * star.speed) % H;
                if (screenY < 0) screenY += H;
                ctx.beginPath();
                ctx.arc(star.x, screenY, star.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw game objects
            platforms.forEach(p => p.draw());
            particles.forEach(p => p.draw());
            
            if (gameState !== 'start') {
                player.draw();
            }

            // Draw UI
            drawUI();
        }

        function drawUI() {
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
            ctx.fillStyle = '#fff';
            ctx.font = '24px Arial';

            if (gameState === 'playing') {
                ctx.fillText(`Score: ${score}`, 20, 40);
            } else if (gameState === 'start') {
                drawOverlay("Bounce Draft", "Click or Tap to Start");
            } else if (gameState === 'gameOver') {
                drawOverlay(`Game Over`, `Score: ${score}`, `High Score: ${highScore}`, `Click to Restart`);
            }
        }
        
        function drawOverlay(...lines) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, W, H);

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const startY = H / 2 - (lines.length - 1) * 30;

            lines.forEach((line, index) => {
                let fontSize = 30;
                if (index === 0) fontSize = 50;
                if (index === lines.length -1) fontSize = 20;

                ctx.font = `bold ${fontSize}px 'Arial', sans-serif`;
                ctx.fillStyle = index === 0 ? '#82E0AA' : '#fff';
                ctx.fillText(line, W / 2, startY + index * 60);
            });
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        function handleUserInteraction() {
            if (gameState === 'start' || gameState === 'gameOver') {
                // Initialize audio context on first user interaction
                if (!audioCtx) {
                    soundManager.init();
                }
                startGame();
            }
        }

        // --- Window Events ---
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const aspectRatio = 9 / 16;
            const availableHeight = window.innerHeight * 0.9;
            const availableWidth = window.innerWidth * 0.95;

            let newHeight = Math.min(800, availableHeight);
            let newWidth = newHeight * aspectRatio;

            if (newWidth > availableWidth) {
                newWidth = availableWidth;
                newHeight = newWidth / aspectRatio;
            }
            
            W = newWidth;
            H = newHeight;

            canvas.width = W;
            canvas.height = H;
            container.style.width = `${W}px`;
            
            if (stars.length === 0) {
                createStars();
            }
        }

        window.addEventListener('resize', resizeCanvas);
        canvas.addEventListener('click', handleUserInteraction);
        canvas.addEventListener('touchstart', handleUserInteraction, { once: true });
        window.addEventListener('keydown', (e) => {
            if ((e.key === ' ' || e.key === 'Enter') && (gameState === 'start' || gameState === 'gameOver')) {
                handleUserInteraction();
            }
        });

        // --- Start Game ---
        init();
        gameLoop();
    </script>
</body>
</html>