<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cascade Crush</title>
    <style>
        :root {
            --glow-color: hsl(186, 100%, 50%);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #111;
            color: #fff;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 30px 5px var(--glow-color);
            border-radius: 10px;
            overflow: hidden;
        }

        canvas {
            display: block;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            text-align: center;
            transition: opacity 0.3s ease;
        }

        .ui-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: clamp(2.5rem, 10vw, 5rem);
            margin-bottom: 0.5em;
            text-shadow: 0 0 10px #fff, 0 0 20px var(--glow-color), 0 0 30px var(--glow-color);
            letter-spacing: 2px;
        }
        
        h2 {
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            margin-bottom: 1em;
            color: var(--glow-color);
        }

        p {
            font-size: clamp(0.8rem, 3vw, 1rem);
            max-width: 80%;
            line-height: 1.5;
            margin-bottom: 1.5em;
        }

        button {
            font-size: clamp(1rem, 4vw, 1.5rem);
            padding: 0.8em 1.5em;
            background: var(--glow-color);
            color: #111;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 0 0 10px var(--glow-color);
            transition: all 0.2s ease;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--glow-color);
        }

        #inGameUI {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            font-size: clamp(1rem, 4vw, 1.5rem);
            font-weight: bold;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #inGameUI.visible {
            opacity: 1;
        }
    </style>
</head>
<body>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="inGameUI">
            <div id="score">Score: 0</div>
            <div id="lives">Lives: ❤️❤️❤️</div>
        </div>

        <div id="startScreen" class="ui-overlay">
            <h1>Cascade Crush</h1>
            <p>Use [A]/[D] or [←]/[→] keys, or your mouse to control the paddle.<br>Crush all the bricks to win!</p>
            <button id="startButton">Start Game</button>
        </div>

        <div id="gameOverScreen" class="ui-overlay hidden">
            <h2 id="gameOverTitle">Game Over</h2>
            <p id="finalScore">Your score: 0</p>
            <button id="restartButton">Play Again</button>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');

        // UI Elements
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const inGameUI = document.getElementById('inGameUI');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const gameOverTitleEl = document.getElementById('gameOverTitle');
        const finalScoreEl = document.getElementById('finalScore');

        let gameState = 'START'; // START, PLAYING, GAMEOVER
        let score = 0;
        let lives = 3;
        
        let paddle, ball, bricks, particles;

        // --- Audio Context ---
        let audioCtx;
        const sounds = {};

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            sounds.hit = createSound(440, 'triangle', 0.1);
            sounds.wall = createSound(220, 'square', 0.05);
            sounds.paddle = createSound(330, 'sine', 0.1);
            sounds.loseLife = createSound(110, 'sawtooth', 0.3);
            sounds.win = createSound(880, 'sine', 0.5);
        }
        
        function createSound(freq, type, duration) {
            return () => {
                if (!audioCtx) return;
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
                
                gainNode.gain.setValueAtTime(1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
                
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + duration);
            };
        }

        // --- Game Objects ---
        const paddleProps = {
            height: 20,
            width: 150,
            speed: 10,
            color: 'hsl(186, 100%, 50%)'
        };

        const ballProps = {
            radius: 12,
            speed: 5,
            color: 'hsl(50, 100%, 50%)'
        };

        const brickProps = {
            rows: 6,
            cols: 10,
            gap: 4,
            height: 25,
            colors: ['#ff4757', '#ff7f50', '#ffa502', '#2ed573', '#1e90ff', '#7d5fff']
        };

        // Classes
        class Paddle {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.dx = 0;
            }

            draw() {
                ctx.beginPath();
                const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(1, 'hsl(186, 100%, 80%)');
                ctx.fillStyle = gradient;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                ctx.roundRect(this.x, this.y, this.width, this.height, 10);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.closePath();
            }

            update() {
                this.x += this.dx;
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
            }
        }

        class Ball {
            constructor(x, y, radius, speed, color) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.speed = speed;
                this.color = color;
                this.dx = speed * (Math.random() < 0.5 ? 1 : -1);
                this.dy = -speed;
            }

            draw() {
                ctx.beginPath();
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
                gradient.addColorStop(0, 'white');
                gradient.addColorStop(0.4, this.color);
                gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 20;
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.closePath();
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
            }
        }
        
        class Brick {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.visible = true;
            }
            
            draw() {
                if (this.visible) {
                    ctx.beginPath();
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = '#111';
                    ctx.lineWidth = 2;
                    ctx.roundRect(this.x, this.y, this.width, this.height, 5);
                    ctx.fill();
                    ctx.stroke();
                    ctx.closePath();
                }
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = Math.random() * 3 + 1;
                this.dx = (Math.random() - 0.5) * 4;
                this.dy = (Math.random() - 0.5) * 4;
                this.alpha = 1;
                this.decay = 0.02;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.fillStyle = this.color;
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.alpha -= this.decay;
            }
        }
        
        // --- Game Logic ---
        function createBricks() {
            bricks = [];
            const totalGapWidth = (brickProps.cols + 1) * brickProps.gap;
            const brickWidth = (canvas.width - totalGapWidth) / brickProps.cols;

            for (let r = 0; r < brickProps.rows; r++) {
                for (let c = 0; c < brickProps.cols; c++) {
                    const x = c * (brickWidth + brickProps.gap) + brickProps.gap;
                    const y = r * (brickProps.height + brickProps.gap) + brickProps.gap + 50;
                    bricks.push(new Brick(x, y, brickWidth, brickProps.height, brickProps.colors[r]));
                }
            }
        }
        
        function createParticles(brick) {
            for (let i = 0; i < 15; i++) {
                particles.push(new Particle(brick.x + brick.width / 2, brick.y + brick.height / 2, brick.color));
            }
        }

        function resetBallAndPaddle() {
            const paddleWidth = Math.min(paddleProps.width, canvas.width * 0.2);
            paddle = new Paddle(
                (canvas.width - paddleWidth) / 2,
                canvas.height - 40,
                paddleWidth,
                paddleProps.height,
                paddleProps.color
            );
            
            const ballRadius = Math.min(ballProps.radius, canvas.width * 0.02);
            ball = new Ball(
                canvas.width / 2,
                paddle.y - ballRadius - 5,
                ballRadius,
                ballProps.speed * (canvas.width / 800), // Scale speed with canvas size
                ballProps.color
            );
        }
        
        function updateUI() {
            scoreEl.textContent = `Score: ${score}`;
            livesEl.innerHTML = `Lives: ${'❤️'.repeat(lives)}`;
        }

        function initGame() {
            score = 0;
            lives = 3;
            particles = [];
            
            setCanvasSize();
            resetBallAndPaddle();
            createBricks();
            updateUI();
        }

        function startGame() {
            initAudio(); // Initialize audio on first user interaction
            gameState = 'PLAYING';
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            inGameUI.classList.add('visible');
            initGame();
            gameLoop();
        }

        function showGameOver(won) {
            gameState = 'GAMEOVER';
            inGameUI.classList.remove('visible');
            gameOverTitleEl.textContent = won ? "You Win! 🎉" : "Game Over";
            finalScoreEl.textContent = `Your final score: ${score}`;
            gameOverScreen.classList.remove('hidden');
            if(won) sounds.win();
        }

        // --- Collision Detection ---
        function checkCollisions() {
            // Ball and walls
            if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
                ball.dx *= -1;
                sounds.wall();
            }
            if (ball.y - ball.radius < 0) {
                ball.dy *= -1;
                sounds.wall();
            }
            
            // Ball and bottom wall (lose life)
            if (ball.y + ball.radius > canvas.height) {
                lives--;
                updateUI();
                sounds.loseLife();
                if (lives > 0) {
                    resetBallAndPaddle();
                } else {
                    showGameOver(false);
                }
            }

            // Ball and paddle
            if (
                ball.y + ball.radius >= paddle.y &&
                ball.x + ball.radius >= paddle.x &&
                ball.x - ball.radius <= paddle.x + paddle.width
            ) {
                // Change ball's reflection angle based on hit position on paddle
                let collidePoint = ball.x - (paddle.x + paddle.width / 2);
                collidePoint = collidePoint / (paddle.width / 2); // Normalize to -1 to 1
                let angle = collidePoint * (Math.PI / 3); // Max angle 60 degrees

                ball.dy = -ball.dy;
                ball.dx = ball.speed * Math.sin(angle);
                sounds.paddle();
                
                // Prevent ball from getting stuck inside paddle
                ball.y = paddle.y - ball.radius;
            }

            // Ball and bricks
            bricks.forEach(brick => {
                if (brick.visible) {
                    if (
                        ball.x > brick.x &&
                        ball.x < brick.x + brick.width &&
                        ball.y > brick.y &&
                        ball.y < brick.y + brick.height
                    ) {
                        ball.dy *= -1;
                        brick.visible = false;
                        score += 10;
                        updateUI();
                        createParticles(brick);
                        sounds.hit();
                    }
                }
            });
            
            // Check for win
            const allBricksCleared = bricks.every(brick => !brick.visible);
            if (allBricksCleared) {
                showGameOver(true);
            }
        }

        // --- Game Loop ---
        function gameLoop() {
            if (gameState !== 'PLAYING') return;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update objects
            paddle.update();
            ball.update();
            particles.forEach((p, index) => {
                p.update();
                if (p.alpha <= 0) {
                    particles.splice(index, 1);
                }
            });

            checkCollisions();

            // Draw objects
            bricks.forEach(brick => brick.draw());
            paddle.draw();
            ball.draw();
            particles.forEach(p => p.draw());

            requestAnimationFrame(gameLoop);
        }

        // --- Controls ---
        let rightPressed = false;
        let leftPressed = false;

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Right' || e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                rightPressed = true;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                leftPressed = true;
            }
            updatePaddleSpeed();
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'Right' || e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                rightPressed = false;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                leftPressed = false;
            }
            updatePaddleSpeed();
        });

        function updatePaddleSpeed() {
            if (rightPressed) {
                paddle.dx = paddleProps.speed;
            } else if (leftPressed) {
                paddle.dx = -paddleProps.speed;
            } else {
                paddle.dx = 0;
            }
        }
        
        document.addEventListener('mousemove', (e) => {
            if (gameState !== 'PLAYING') return;
            const rect = canvas.getBoundingClientRect();
            let mouseX = e.clientX - rect.left;
            paddle.x = mouseX - paddle.width / 2;
        });


        // --- Responsiveness ---
        function setCanvasSize() {
            const aspectRatio = 16 / 10;
            let newWidth = window.innerWidth * 0.9;
            let newHeight = window.innerHeight * 0.9;

            if (newWidth / newHeight > aspectRatio) {
                newWidth = newHeight * aspectRatio;
            } else {
                newHeight = newWidth / aspectRatio;
            }
            
            gameContainer.style.width = `${newWidth}px`;
            gameContainer.style.height = `${newHeight}px`;
            canvas.width = newWidth;
            canvas.height = newHeight;
            
            if (gameState === 'PLAYING') {
                initGame(); // Re-initialize game to scale objects properly
            }
        }
        
        // --- Event Listeners ---
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        window.addEventListener('resize', setCanvasSize);
        
        // --- Initial Call ---
        setCanvasSize();

    });
    </script>
</body>
</html>