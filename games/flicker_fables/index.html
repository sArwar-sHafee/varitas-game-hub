<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>Flicker Fables</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background: #0a0514; /* Deep purple-black for a magical feel */
        }
        canvas {
            display: block;
            background: radial-gradient(circle, #2a1a4a 0%, #0a0514 100%);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

<script>
class AudioPlayer {
    constructor() {
        this.audioCtx = null;
        this.sounds = {};
    }

    // Must be called after a user interaction
    init() {
        if (this.audioCtx) return;
        try {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) {
            console.error("Web Audio API is not supported in this browser");
        }
    }

    // A generic function to create a sound
    createSound(freq, duration, type, volume, attack = 0.01, decay = 0.1) {
        if (!this.audioCtx) return;
        const oscillator = this.audioCtx.createOscillator();
        const gainNode = this.audioCtx.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioCtx.destination);

        const now = this.audioCtx.currentTime;
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(freq, now);
        
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(volume, now + attack);
        
        // Use attack + decay for total envelope time, preventing "time in the past" errors.
        const decayEndTime = now + attack + decay;
        gainNode.gain.linearRampToValueAtTime(0, decayEndTime);

        oscillator.start(now);
        oscillator.stop(now + duration);
    }

    playClick() { this.createSound(250, 0.15, 'triangle', 0.3); }
    playHover() { this.createSound(800, 0.05, 'sine', 0.1); }
    playScore() { this.createSound(523, 0.3, 'sine', 0.4); } // C5
    playGameOverGood() { this.createSound(783, 0.8, 'sine', 0.5); } // G5
    playGameOverBad() { this.createSound(164, 1.2, 'sawtooth', 0.4); } // E3
    playTyping() { this.createSound(600, 0.05, 'square', 0.1); }
    playStartGame() { this.createSound(392, 0.5, 'sine', 0.5); } // G4
}

class Particle {
    constructor(x, y, canvasWidth, canvasHeight) {
        this.x = x;
        this.y = y;
        this.canvasWidth = canvasWidth;
        this.canvasHeight = canvasHeight;
        this.size = Math.random() * 2 + 1;
        this.speedX = Math.random() * 1 - 0.5;
        this.speedY = Math.random() * 1 - 0.5;
        this.color = `rgba(255, 220, 150, ${Math.random() * 0.8})`;
    }

    update() {
        this.x += this.speedX;
        this.y += this.speedY;

        if (this.size > 0.1) this.size -= 0.01;
        if (this.x < 0 || this.x > this.canvasWidth || this.y < 0 || this.y > this.canvasHeight) {
            this.x = Math.random() * this.canvasWidth;
            this.y = Math.random() * this.canvasHeight;
            this.size = Math.random() * 2 + 1;
        }
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Game {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.audioPlayer = new AudioPlayer();
        
        this.gameState = 'START'; // START, PLAYING, TRANSITION, GAMEOVER
        this.score = 0;
        this.currentSceneId = 'start';
        this.mouse = { x: 0, y: 0 };
        
        this.particles = [];
        this.buttons = [];
        this.hoveredButton = null;
        
        this.typewriter = {
            text: '',
            fullText: '',
            index: 0,
            speed: 30, // ms per char
            lastTime: 0,
            isDone: false
        };
        
        this.transition = {
            alpha: 0,
            duration: 500, // ms
            state: 'in', // 'in' or 'out'
            nextState: '',
            onComplete: null
        };
        
        this.story = {
            // ... story data will be defined in init ...
        };

        this.lastTime = 0;
    }

    init() {
        this.defineStory();
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('click', (e) => this.handleMouseClick(e));
        document.addEventListener('keydown', (e) => this.handleKeyPress(e));
        
        for (let i = 0; i < 100; i++) {
            this.particles.push(new Particle(
                Math.random() * this.canvas.width,
                Math.random() * this.canvas.height,
                this.canvas.width,
                this.canvas.height
            ));
        }
        
        this.startTransition('in', 'START');
    }

    defineStory() {
        this.story = {
            'start': {
                text: "You are deep in the Whispering Woods as twilight descends. The air is cool and smells of damp earth. Before you, half-buried in moss, a small, ornate lantern emits a soft, flickering light.",
                emoji: "ðŸŒ³",
                choices: [
                    { text: "1. Pick up the lantern.", nextScene: 'lantern', points: 5 },
                    { text: "2. Ignore it and walk on.", nextScene: 'ignoreLantern' }
                ]
            },
            'ignoreLantern': {
                text: "You decide the strange lantern is not your concern and press on into the darkening woods. Without its light, you quickly lose your way. The whispers of the woods turn to menacing hisses. You are lost.",
                emoji: "ðŸ§­",
                isEnd: true,
                endingType: 'bad'
            },
            'lantern': {
                text: "As you touch the warm glass, a gentle voice echoes in your mind, not from the lantern, but *through* it. 'Thank you, traveler. I can guide you. Two paths lie ahead... which will you choose?'",
                emoji: "ðŸ®",
                choices: [
                    { text: "1. The path to the Glimmering Caves.", nextScene: 'caves' },
                    { text: "2. The path to the Sunken Citadel.", nextScene: 'citadel' }
                ]
            },
            'caves': {
                text: "You follow a trail of sparkling moss to a cave entrance humming with energy. Inside, a tiny gnome with a crystalline beard blocks your path. 'A riddle for a reward!' he squeaks. 'I have cities, but no houses; forests, but no trees; and water, but no fish. What am I?'",
                emoji: "ðŸ’Ž",
                choices: [
                    { text: "1. A dream.", nextScene: 'gnomeFail' },
                    { text: "2. A map.", nextScene: 'gnomeSuccess', points: 15 },
                    { text: "3. A book.", nextScene: 'gnomeFail' }
                ]
            },
            'gnomeSuccess': {
                text: "'Correct!' The gnome giggles, tapping his staff. A hidden passage opens, revealing a chest overflowing with ancient coins and jewels. You've found the lost treasure of the Glimmering Gnomes!",
                emoji: "ðŸ†",
                isEnd: true,
                endingType: 'good'
            },
            'gnomeFail': {
                text: "'Incorrect!' The gnome sighs dramatically. 'No treasure for you.' With a snap of his fingers, you find yourself back at your own doorstep, the adventure a fuzzy memory. It was a harmless, if disappointing, encounter.",
                emoji: "ðŸ¡",
                isEnd: true,
                endingType: 'neutral'
            },
            'citadel': {
                text: "The lantern's light guides you to a staircase descending into a serene, underwater citadel. A grumpy water spirit, shaped like a giant koi fish, guards a sealed gate. 'None shall pass!' it gurgles, creating a powerful current.",
                emoji: "ðŸ¯",
                choices: [
                    { text: "1. Offer it a shiny pebble.", nextScene: 'spiritPleased', points: 15 },
                    { text: "2. Try to swim past it.", nextScene: 'spiritAngry' }
                ]
            },
            'spiritPleased': {
                text: "The spirit's eyes widen at the pebble, which shimmers with captured starlight. It hums with pleasure. 'A gift! How kind.' It moves aside, revealing a passage to a hidden, moonlit grotto of incredible beauty. You've discovered a place of pure magic.",
                emoji: "âœ¨",
                isEnd: true,
                endingType: 'good'
            },
            'spiritAngry': {
                text: "You try to dart past the spirit. 'Insolence!' it roars, its voice a tidal wave. It summons a fierce whirlpool, trapping you in an endless, dizzying dance. The Sunken Citadel becomes your eternal, watery prison.",
                emoji: "ðŸŒ€",
                isEnd: true,
                endingType: 'bad'
            }
        };
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.particles.forEach(p => {
            p.canvasWidth = this.canvas.width;
            p.canvasHeight = this.canvas.height;
        });
        if (this.gameState === 'PLAYING' || this.gameState === 'GAMEOVER') {
             this.setupScene(this.currentSceneId, true);
        }
    }
    
    startTransition(direction, nextState, onComplete = null) {
        this.transition.state = direction;
        this.transition.alpha = (direction === 'out') ? 0 : 1;
        this.gameState = 'TRANSITION';
        this.transition.nextState = nextState;
        this.transition.onComplete = onComplete;
    }

    start() {
        this.loop(0);
    }

    loop(timestamp) {
        const deltaTime = timestamp - this.lastTime;
        this.lastTime = timestamp;

        this.update(timestamp, deltaTime);
        this.draw();
        
        requestAnimationFrame((t) => this.loop(t));
    }

    update(timestamp, deltaTime) {
        // Ensure deltaTime is not excessively large (e.g., when tab is inactive)
        const safeDeltaTime = Math.min(deltaTime, 100);

        this.particles.forEach(p => p.update());

        if (this.gameState === 'TRANSITION') {
            const change = (safeDeltaTime / this.transition.duration);
            if (this.transition.state === 'out') {
                this.transition.alpha = Math.min(1, this.transition.alpha + change);
                if (this.transition.alpha >= 1) {
                    if (this.transition.onComplete) this.transition.onComplete();
                    this.startTransition('in', this.transition.nextState);
                }
            } else { // 'in'
                this.transition.alpha = Math.max(0, this.transition.alpha - change);
                if (this.transition.alpha <= 0) {
                    this.gameState = this.transition.nextState;
                }
            }
        }
        
        if (this.gameState === 'PLAYING' && !this.typewriter.isDone) {
            if (timestamp > this.typewriter.lastTime + this.typewriter.speed) {
                this.typewriter.index++;
                this.typewriter.text = this.typewriter.fullText.substring(0, this.typewriter.index);
                this.typewriter.lastTime = timestamp;
                if (this.typewriter.index % 3 === 0) this.audioPlayer.playTyping();
                if (this.typewriter.index >= this.typewriter.fullText.length) {
                    this.typewriter.isDone = true;
                }
            }
        }
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw background gradient
        const gradient = this.ctx.createRadialGradient(this.canvas.width/2, this.canvas.height/2, 0, this.canvas.width/2, this.canvas.height/2, Math.max(this.canvas.width, this.canvas.height));
        gradient.addColorStop(0, '#2a1a4a');
        gradient.addColorStop(1, '#0a0514');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.particles.forEach(p => p.draw(this.ctx));

        switch (this.gameState) {
            case 'START': this.drawStartScreen(); break;
            case 'PLAYING': this.drawGameScreen(); break;
            case 'GAMEOVER': this.drawGameOverScreen(); break;
        }
        
        // Draw transition overlay
        if (this.gameState === 'TRANSITION') {
            this.ctx.fillStyle = `rgba(10, 5, 20, ${this.transition.alpha})`;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
    }
    
    // --- State Specific Drawing ---
    
    drawStartScreen() {
        this.drawTitleText();
        this.drawStartButton();
    }
    
    drawTitleText() {
        this.ctx.textAlign = 'center';
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        
        // Title
        const titleSize = Math.min(this.canvas.width * 0.1, 100);
        this.ctx.font = `bold ${titleSize}px 'Georgia', serif`;
        this.ctx.shadowColor = 'rgba(255, 180, 255, 0.7)';
        this.ctx.shadowBlur = 20;
        this.ctx.fillText("Flicker Fables", this.canvas.width / 2, this.canvas.height * 0.3);
        
        // Subtitle
        const subtitleSize = Math.min(this.canvas.width * 0.03, 24);
        this.ctx.font = `${subtitleSize}px 'Arial', sans-serif`;
        this.ctx.shadowBlur = 10;
        this.ctx.fillText("A Tiny Text Adventure", this.canvas.width / 2, this.canvas.height * 0.3 + titleSize * 0.8);
        
        this.ctx.shadowBlur = 0;
    }
    
    drawStartButton() {
        this.buttons = []; // Clear buttons
        const isHovered = this.hoveredButton === 0;
        const button = {
            x: this.canvas.width / 2 - 150,
            y: this.canvas.height * 0.6,
            w: 300,
            h: 70,
            text: "Begin Your Tale"
        };
        this.buttons.push(button);

        this.drawButton(button, 0);

        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        const instructionSize = Math.min(this.canvas.width * 0.02, 16);
        this.ctx.font = `${instructionSize}px 'Arial', sans-serif`;
        this.ctx.fillText("Click or press any key to start", this.canvas.width / 2, button.y + button.h + 40);
    }
    
    drawGameScreen() {
        const scene = this.story[this.currentSceneId];
        const margin = this.canvas.width * 0.1;
        const contentWidth = this.canvas.width - margin * 2;
        const isMobile = this.canvas.width < 768;

        // Draw Score
        this.ctx.textAlign = 'left';
        this.ctx.fillStyle = '#ffd700';
        const scoreSize = Math.min(this.canvas.width * 0.04, 28);
        this.ctx.font = `bold ${scoreSize}px 'Georgia', serif`;
        this.ctx.fillText(`Score: ${this.score}`, margin, this.canvas.height * 0.1);

        // Draw Emoji
        const emojiSize = Math.min(this.canvas.width * 0.15, 120);
        this.ctx.font = `${emojiSize}px sans-serif`;
        this.ctx.textAlign = 'center';
        this.ctx.fillText(scene.emoji, this.canvas.width / 2, this.canvas.height * 0.25);

        // Draw Text
        this.ctx.textAlign = 'left';
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        const textSize = isMobile ? 18 : Math.min(this.canvas.width * 0.02, 22);
        const lineHeight = textSize * 1.5;
        this.ctx.font = `${textSize}px 'Georgia', serif`;
        const lastY = this.wrapText(this.typewriter.text, margin, this.canvas.height * 0.4, contentWidth, lineHeight);

        // Draw choices if typewriter is done
        if (this.typewriter.isDone && scene.choices) {
            this.buttons = [];
            scene.choices.forEach((choice, index) => {
                const buttonHeight = isMobile ? 60 : 60;
                const buttonMargin = 20;
                const button = {
                    x: margin,
                    y: lastY + 50 + index * (buttonHeight + buttonMargin),
                    w: contentWidth,
                    h: buttonHeight,
                    text: choice.text
                };
                this.buttons.push(button);
                this.drawButton(button, index);
            });
        }
    }
    
    drawGameOverScreen() {
        const scene = this.story[this.currentSceneId];
        this.ctx.textAlign = 'center';

        const titleSize = Math.min(this.canvas.width * 0.1, 80);
        this.ctx.font = `bold ${titleSize}px 'Georgia', serif`;
        this.ctx.shadowColor = 'rgba(255, 180, 255, 0.7)';
        this.ctx.shadowBlur = 20;
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        this.ctx.fillText("The End", this.canvas.width / 2, this.canvas.height * 0.2);

        const emojiSize = Math.min(this.canvas.width * 0.15, 120);
        this.ctx.font = `${emojiSize}px sans-serif`;
        this.ctx.fillText(scene.emoji, this.canvas.width / 2, this.canvas.height * 0.35);

        this.ctx.shadowBlur = 0;
        const textSize = Math.min(this.canvas.width * 0.025, 24);
        const lineHeight = textSize * 1.5;
        this.ctx.font = `${textSize}px 'Georgia', serif`;
        this.wrapText(scene.text, this.canvas.width / 2, this.canvas.height * 0.5, this.canvas.width * 0.8, lineHeight, true);

        this.ctx.fillStyle = '#ffd700';
        const scoreSize = Math.min(this.canvas.width * 0.05, 40);
        this.ctx.font = `bold ${scoreSize}px 'Georgia', serif`;
        this.ctx.fillText(`Final Score: ${this.score}`, this.canvas.width / 2, this.canvas.height * 0.75);

        this.buttons = [];
        const button = {
            x: this.canvas.width / 2 - 150,
            y: this.canvas.height * 0.85,
            w: 300,
            h: 70,
            text: "Play Again"
        };
        this.buttons.push(button);
        this.drawButton(button, 0);
    }
    
    // --- Helper Functions ---
    
    wrapText(text, x, y, maxWidth, lineHeight, centered = false) {
        const words = text.split(' ');
        let line = '';
        const lines = [];
        
        for (let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            const metrics = this.ctx.measureText(testLine);
            if (metrics.width > maxWidth && n > 0) {
                lines.push(line);
                line = words[n] + ' ';
            } else {
                line = testLine;
            }
        }
        lines.push(line);
        
        if (centered) {
            this.ctx.textAlign = 'center';
        } else {
            this.ctx.textAlign = 'left';
        }
        
        lines.forEach((l, i) => {
            this.ctx.fillText(l.trim(), x, y + i * lineHeight);
        });
        
        return y + (lines.length - 1) * lineHeight;
    }
    
    drawButton(button, index) {
        const isHovered = this.hoveredButton === index;
        const scale = isHovered ? 1.05 : 1.0;
        const cornerRadius = 15;
        
        const buttonX = button.x + (button.w * (1 - scale)) / 2;
        const buttonY = button.y + (button.h * (1 - scale)) / 2;
        const buttonW = button.w * scale;
        const buttonH = button.h * scale;

        // Button body
        this.ctx.beginPath();
        this.ctx.moveTo(buttonX + cornerRadius, buttonY);
        this.ctx.lineTo(buttonX + buttonW - cornerRadius, buttonY);
        this.ctx.quadraticCurveTo(buttonX + buttonW, buttonY, buttonX + buttonW, buttonY + cornerRadius);
        this.ctx.lineTo(buttonX + buttonW, buttonY + buttonH - cornerRadius);
        this.ctx.quadraticCurveTo(buttonX + buttonW, buttonY + buttonH, buttonX + buttonW - cornerRadius, buttonY + buttonH);
        this.ctx.lineTo(buttonX + cornerRadius, buttonY + buttonH);
        this.ctx.quadraticCurveTo(buttonX, buttonY + buttonH, buttonX, buttonY + buttonH - cornerRadius);
        this.ctx.lineTo(buttonX, buttonY + cornerRadius);
        this.ctx.quadraticCurveTo(buttonX, buttonY, buttonX + cornerRadius, buttonY);
        this.ctx.closePath();

        const grad = this.ctx.createLinearGradient(buttonX, buttonY, buttonX, buttonY + buttonH);
        if (isHovered) {
            grad.addColorStop(0, '#7c4dff');
            grad.addColorStop(1, '#512da8');
            this.ctx.shadowColor = 'rgba(190, 150, 255, 0.8)';
            this.ctx.shadowBlur = 20;
        } else {
            grad.addColorStop(0, '#5e35b1');
            grad.addColorStop(1, '#311b92');
            this.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            this.ctx.shadowBlur = 10;
        }
        this.ctx.fillStyle = grad;
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // Button text
        const fontSize = Math.min(button.h * 0.4, 22);
        this.ctx.font = `bold ${fontSize}px 'Arial', sans-serif`;
        this.ctx.fillStyle = '#fff';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(button.text, button.x + button.w / 2, button.y + button.h / 2);
    }
    
    // --- Input Handling ---
    
    handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.mouse.x = e.clientX - rect.left;
        this.mouse.y = e.clientY - rect.top;

        let oldHovered = this.hoveredButton;
        this.hoveredButton = null;
        this.buttons.forEach((button, index) => {
            if (this.mouse.x > button.x && this.mouse.x < button.x + button.w &&
                this.mouse.y > button.y && this.mouse.y < button.y + button.h) {
                this.hoveredButton = index;
            }
        });
        
        if (this.hoveredButton !== null && this.hoveredButton !== oldHovered) {
            this.audioPlayer.playHover();
        }
    }

    handleMouseClick(e) {
        this.audioPlayer.init(); // Initialize audio on first click
        
        if (this.gameState === 'START') {
            this.startGame();
        } else if (this.gameState === 'PLAYING') {
            if (this.hoveredButton !== null) {
                this.makeChoice(this.hoveredButton);
            }
        } else if (this.gameState === 'GAMEOVER') {
            if (this.hoveredButton === 0) {
                this.restartGame();
            }
        }
    }
    
    handleKeyPress(e) {
        this.audioPlayer.init();
        
        if (this.gameState === 'START') {
            this.startGame();
        } else if (this.gameState === 'PLAYING') {
            const keyNum = parseInt(e.key);
            if (!isNaN(keyNum) && keyNum > 0 && keyNum <= this.buttons.length) {
                this.makeChoice(keyNum - 1);
            }
        } else if (this.gameState === 'GAMEOVER') {
            this.restartGame();
        }
    }
    
    // --- Game Logic ---

    startGame() {
        this.audioPlayer.playStartGame();
        this.startTransition('out', 'PLAYING', () => {
            this.gameState = 'PLAYING';
            this.score = 0;
            this.currentSceneId = 'start';
            this.setupScene('start');
        });
    }

    setupScene(sceneId, immediate = false) {
        this.currentSceneId = sceneId;
        const scene = this.story[sceneId];
        
        this.typewriter.fullText = scene.text;
        this.typewriter.index = immediate ? scene.text.length : 0;
        this.typewriter.text = immediate ? scene.text : '';
        this.typewriter.isDone = immediate;
        
        this.buttons = [];
        this.hoveredButton = null;
    }

    makeChoice(choiceIndex) {
        if (!this.typewriter.isDone) return;
        
        const scene = this.story[this.currentSceneId];
        if (!scene.choices || !scene.choices[choiceIndex]) return;

        const choice = scene.choices[choiceIndex];
        this.audioPlayer.playClick();
        
        if (choice.points) {
            this.score += choice.points;
            this.audioPlayer.playScore();
        }
        
        const nextScene = this.story[choice.nextScene];
        
        if (nextScene.isEnd) {
             this.startTransition('out', 'GAMEOVER', () => {
                this.currentSceneId = choice.nextScene;
                this.setupScene(choice.nextScene, true);
                if(nextScene.endingType === 'good') this.audioPlayer.playGameOverGood();
                else if (nextScene.endingType === 'bad') this.audioPlayer.playGameOverBad();
             });
        } else {
            this.startTransition('out', 'PLAYING', () => {
                this.setupScene(choice.nextScene);
            });
        }
    }
    
    restartGame() {
        this.audioPlayer.playClick();
        this.startTransition('out', 'START');
    }
}


window.onload = () => {
    const canvas = document.getElementById('gameCanvas');
    const game = new Game(canvas);
    game.init();
    game.start();
};

</script>
</body>
</html>