<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Fist Paper Blade</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            color: #fff;
        }
        body {
            background: #1a1a2e;
            background: radial-gradient(circle, #16213e 0%, #0f3460 50%, #1a1a2e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            border-radius: 10px;
            background-color: rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        // ES6+ JavaScript Game Code
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- GAME CONFIGURATION ---
        const WINNING_SCORE = 5;
        const CHOICES = [
            { id: 0, name: 'Fist', emoji: '✊', beats: 2 }, // Fist beats Blade
            { id: 1, name: 'Paper', emoji: '✋', beats: 0 }, // Paper beats Fist
            { id: 2, name: 'Blade', emoji: '✌️', beats: 1 }  // Blade beats Paper
        ];

        // --- GAME STATE ---
        let gameState = 'START'; // START, PLAYING, ROUND_RESULT, GAME_OVER
        let playerScore = 0;
        let computerScore = 0;
        let playerChoice = null;
        let computerChoice = null;
        let roundResult = null; // 'WIN', 'LOSE', 'DRAW'
        let roundMessage = '';
        let lastTime = 0;
        let animationTimer = 0;
        let hoverChoice = -1; // -1 for none, 0, 1, 2 for choices
        const particles = [];

        // --- AUDIO ---
        let audioCtx;
        function initAudio() {
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error("Web Audio API is not supported in this browser");
                }
            }
        }
        
        function playSound(type) {
            if (!audioCtx) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            gainNode.gain.setValueAtTime(0, audioCtx.currentTime);

            switch (type) {
                case 'select':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.3, audioCtx.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.2);
                    break;
                case 'win':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(523.25, audioCtx.currentTime); // C5
                    gainNode.gain.linearRampToValueAtTime(0.4, audioCtx.currentTime + 0.05);
                    oscillator.frequency.setValueAtTime(659.25, audioCtx.currentTime + 0.1); // E5
                    oscillator.frequency.setValueAtTime(783.99, audioCtx.currentTime + 0.2); // G5
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.4);
                    break;
                case 'lose':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.05);
                    oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.3);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.3);
                    break;
                case 'draw':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.15);
                    const osc2 = audioCtx.createOscillator();
                    osc2.connect(gainNode);
                    osc2.type = 'square';
                    osc2.frequency.setValueAtTime(330, audioCtx.currentTime + 0.1);
                    osc2.start(audioCtx.currentTime + 0.1);
                    osc2.stop(audioCtx.currentTime + 0.25);
                    break;
            }

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.5);
        }

        // --- RESPONSIVENESS ---
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const aspectRatio = 16 / 9;
            let newWidth = container.clientWidth;
            let newHeight = container.clientHeight;
            const containerRatio = newWidth / newHeight;

            if (containerRatio > aspectRatio) {
                newWidth = newHeight * aspectRatio;
            } else {
                newHeight = newWidth / aspectRatio;
            }

            canvas.width = newWidth;
            canvas.height = newHeight;
        }

        // --- PARTICLE SYSTEM ---
        function createParticles(x, y, color, count = 30) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: Math.random() * 3 + 1,
                    life: Math.random() * 60 + 30, // frames
                    color
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1; // gravity
                p.life--;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 60;
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        // --- DRAWING HELPERS ---
        function drawText(text, x, y, size, color, align = 'center', shadow = true) {
            ctx.font = `bold ${size}px 'Helvetica Neue', Arial, sans-serif`;
            ctx.textAlign = align;
            if (shadow) {
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
            }
            ctx.fillStyle = color;
            ctx.fillText(text, x, y);
            // Reset shadow
            ctx.shadowColor = 'transparent';
        }

        function drawChoiceButton(choice, x, y, size, isHovered) {
            const boxSize = size * 1.2;
            ctx.save();
            if (isHovered) {
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 20;
                const pulse = Math.sin(Date.now() * 0.01) * 0.05 + 1.05;
                ctx.translate(x, y);
                ctx.scale(pulse, pulse);
                ctx.translate(-x, -y);
            }

            // Draw button background
            const gradient = ctx.createLinearGradient(x - boxSize / 2, y - boxSize / 2, x + boxSize / 2, y + boxSize / 2);
            gradient.addColorStop(0, '#1f4287');
            gradient.addColorStop(1, '#278ea5');
            ctx.fillStyle = isHovered ? '#21e6c1' : gradient;
            ctx.strokeStyle = '#e0f7fa';
            ctx.lineWidth = 4;
            
            ctx.beginPath();
            // The roundRect function is supported in all modern browsers
            if (ctx.roundRect) {
                ctx.roundRect(x - boxSize / 2, y - boxSize / 2, boxSize, boxSize, 15);
            } else { // Fallback for older browsers
                ctx.rect(x - boxSize / 2, y - boxSize / 2, boxSize, boxSize);
            }
            ctx.fill();
            ctx.stroke();
            
            // Draw emoji and text
            ctx.shadowColor = 'transparent';
            ctx.font = `${size}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(choice.emoji, x, y - size * 0.1);

            drawText(choice.name, x, y + size * 0.5, size * 0.2, '#fff', 'center', false);
            
            ctx.restore();
        }

        // --- GAME LOGIC ---
        function startGame() {
            gameState = 'PLAYING';
            playerScore = 0;
            computerScore = 0;
            resetRound();
        }
        
        function restartGame() {
            playSound('select');
            startGame();
        }

        function resetRound() {
            playerChoice = null;
            computerChoice = null;
            roundResult = null;
            roundMessage = '';
            animationTimer = 0;
            gameState = 'PLAYING';
        }

        function makeChoice(choiceId) {
            if (gameState !== 'PLAYING') return;
            playSound('select');
            playerChoice = CHOICES[choiceId];
            computerChoice = CHOICES[Math.floor(Math.random() * CHOICES.length)];
            determineWinner();
            gameState = 'ROUND_RESULT';
            animationTimer = 0;
        }

        function determineWinner() {
            if (playerChoice.id === computerChoice.id) {
                roundResult = 'DRAW';
                roundMessage = "It's a Draw!";
                playSound('draw');
            } else if (playerChoice.beats === computerChoice.id) {
                roundResult = 'WIN';
                roundMessage = 'You Win This Round!';
                playerScore++;
                playSound('win');
                createParticles(canvas.width / 4, canvas.height / 2, '#21e6c1');
            } else {
                roundResult = 'LOSE';
                roundMessage = 'The Machine Wins!';
                computerScore++;
                playSound('lose');
                createParticles(canvas.width * 3 / 4, canvas.height / 2, '#ff4747');
            }

            if (playerScore >= WINNING_SCORE || computerScore >= WINNING_SCORE) {
                setTimeout(() => {
                    gameState = 'GAME_OVER';
                }, 2000); // Wait 2s before showing game over screen
            }
        }
        
        // --- UPDATE FUNCTION ---
        function update(deltaTime) {
            if (gameState === 'ROUND_RESULT') {
                animationTimer += deltaTime;
                if (animationTimer > 2000) { // 2 second result display
                     if (gameState !== 'GAME_OVER') { // Prevent reset if game is over
                        resetRound();
                    }
                }
            }
            updateParticles();
        }
        
        // --- DRAW FUNCTION ---
        function draw() {
            // Clear canvas with a gradient
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, '#1a1a2e');
            bgGradient.addColorStop(1, '#0f3460');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const w = canvas.width;
            const h = canvas.height;

            switch (gameState) {
                case 'START':
                    drawStartScreen(w, h);
                    break;
                case 'PLAYING':
                    drawPlayingScreen(w, h);
                    break;
                case 'ROUND_RESULT':
                    drawResultScreen(w, h);
                    break;
                case 'GAME_OVER':
                    drawGameOverScreen(w, h);
                    break;
            }

            drawParticles();
        }

        function drawStartScreen(w, h) {
            const pulse = Math.sin(Date.now() * 0.002) * 0.02 + 1;
            drawText('Fist Paper Blade', w / 2, h * 0.3, w * 0.08 * pulse, '#e0f7fa');
            drawText('✊ ✋ ✌️', w / 2, h * 0.45, w * 0.07, '#fff');
            drawText('Click or Press any Key to Start', w / 2, h * 0.65, w * 0.03, '#21e6c1');
        }
        
        function drawPlayingScreen(w, h) {
            // Draw scores
            drawText('Player', w * 0.25, h * 0.1, w * 0.04, '#21e6c1');
            drawText(playerScore, w * 0.25, h * 0.2, w * 0.07, '#fff');

            drawText('Computer', w * 0.75, h * 0.1, w * 0.04, '#ff4747');
            drawText(computerScore, w * 0.75, h * 0.2, w * 0.07, '#fff');
            
            // Draw separator
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(w/2 - 2, h*0.05, 4, h*0.2);

            // Draw instruction
            drawText('Choose your weapon!', w / 2, h * 0.4, w * 0.05, '#e0f7fa');

            // Draw placeholders
            ctx.font = `${w * 0.15}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText('🤔', w * 0.25, h * 0.5);
            ctx.fillText('🤖', w * 0.75, h * 0.5);

            // Draw choice buttons
            const buttonSize = w * 0.12;
            const buttonY = h * 0.8;
            drawChoiceButton(CHOICES[0], w * 0.25, buttonY, buttonSize, hoverChoice === 0);
            drawChoiceButton(CHOICES[1], w * 0.5, buttonY, buttonSize, hoverChoice === 1);
            drawChoiceButton(CHOICES[2], w * 0.75, buttonY, buttonSize, hoverChoice === 2);
            
            // Draw key hints
            drawText('[1]', w * 0.25, buttonY + buttonSize * 0.85, w * 0.02, '#fff');
            drawText('[2]', w * 0.5, buttonY + buttonSize * 0.85, w * 0.02, '#fff');
            drawText('[3]', w * 0.75, buttonY + buttonSize * 0.85, w * 0.02, '#fff');
        }

        function drawResultScreen(w, h) {
            // Draw scores (dimmed)
            ctx.globalAlpha = 0.5;
            drawText('Player', w * 0.25, h * 0.1, w * 0.04, '#21e6c1');
            drawText(playerScore, w * 0.25, h * 0.2, w * 0.07, '#fff');
            drawText('Computer', w * 0.75, h * 0.1, w * 0.04, '#ff4747');
            drawText(computerScore, w * 0.75, h * 0.2, w * 0.07, '#fff');
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(w/2 - 2, h*0.05, 4, h*0.2);
            ctx.globalAlpha = 1;

            // Animate choices
            const progress = Math.min(animationTimer / 500, 1); // 0.5s animation
            const scale = 1.5 * (1 - Math.pow(1 - progress, 3)); // Ease out cubic
            const emojiSize = w * 0.15 * scale;
            ctx.font = `${emojiSize}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Draw player's choice
            ctx.save();
            ctx.translate(w * 0.25, h / 2);
            if (roundResult === 'WIN') ctx.rotate(Math.sin(Date.now() * 0.02) * 0.1);
            ctx.fillText(playerChoice.emoji, 0, 0);
            ctx.restore();

            // Draw computer's choice
            ctx.save();
            ctx.translate(w * 0.75, h / 2);
            if (roundResult === 'LOSE') ctx.rotate(Math.sin(Date.now() * 0.02) * 0.1);
            ctx.fillText(computerChoice.emoji, 0, 0);
            ctx.restore();

            // Draw result message
            if (progress === 1) {
                let color = '#e0f7fa';
                if (roundResult === 'WIN') color = '#21e6c1';
                if (roundResult === 'LOSE') color = '#ff4747';
                drawText(roundMessage, w / 2, h * 0.75, w * 0.06, color);
            }
        }

        function drawGameOverScreen(w, h) {
            const message = playerScore >= WINNING_SCORE ? "You are the Champion!" : "The Machine Prevails!";
            const color = playerScore >= WINNING_SCORE ? '#21e6c1' : '#ff4747';
            
            const pulse = Math.sin(Date.now() * 0.003) * 0.02 + 1;
            drawText('Game Over', w / 2, h * 0.2, w * 0.08, '#e0f7fa');
            drawText(message, w / 2, h * 0.4, w * 0.06 * pulse, color);
            drawText(`Final Score: ${playerScore} - ${computerScore}`, w / 2, h * 0.6, w * 0.04, '#fff');
            drawText('Click or Press Enter to Play Again', w / 2, h * 0.8, w * 0.03, '#e0f7fa');
        }


        // --- MAIN GAME LOOP ---
        function gameLoop(timestamp) {
            // Fix for initial frame having large deltaTime
            if (lastTime === 0) {
                lastTime = timestamp;
            }
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        // --- EVENT LISTENERS ---
        function handleKeyDown(e) {
            initAudio(); // Initialize audio on first user interaction
            if (gameState === 'START') {
                restartGame(); // Changed for consistency, plays sound
            } else if (gameState === 'PLAYING') {
                if (e.key === '1') makeChoice(0);
                if (e.key === '2') makeChoice(1);
                if (e.key === '3') makeChoice(2);
            } else if (gameState === 'GAME_OVER') {
                if (e.key === 'Enter') {
                    restartGame();
                }
            }
        }
        
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates to match canvas resolution if CSS scales it
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY
            };
        }

        function handleClick(e) {
            initAudio();
            if (gameState === 'START' || gameState === 'GAME_OVER') {
                restartGame();
            } else if (gameState === 'PLAYING') {
                const pos = getMousePos(canvas, e);
                const buttonSize = canvas.width * 0.12;
                const boxSize = buttonSize * 1.2;
                const buttonY = canvas.height * 0.8;
                
                const choicesBoxes = [
                    { x: canvas.width * 0.25 - boxSize/2, y: buttonY - boxSize/2, w: boxSize, h: boxSize, choice: 0 },
                    { x: canvas.width * 0.50 - boxSize/2, y: buttonY - boxSize/2, w: boxSize, h: boxSize, choice: 1 },
                    { x: canvas.width * 0.75 - boxSize/2, y: buttonY - boxSize/2, w: boxSize, h: boxSize, choice: 2 }
                ];
                
                for(const box of choicesBoxes) {
                    if(pos.x > box.x && pos.x < box.x + box.w && pos.y > box.y && pos.y < box.y + box.h) {
                        makeChoice(box.choice);
                        break;
                    }
                }
            }
        }
        
        function handleMouseMove(e) {
            if (gameState !== 'PLAYING') {
                hoverChoice = -1;
                document.body.style.cursor = 'default';
                return;
            }
            const pos = getMousePos(canvas, e);
            const buttonSize = canvas.width * 0.12;
            const boxSize = buttonSize * 1.2;
            const buttonY = canvas.height * 0.8;
            
            const choicesBoxes = [
                { x: canvas.width * 0.25 - boxSize/2, y: buttonY - boxSize/2, w: boxSize, h: boxSize, choice: 0 },
                { x: canvas.width * 0.50 - boxSize/2, y: buttonY - boxSize/2, w: boxSize, h: boxSize, choice: 1 },
                { x: canvas.width * 0.75 - boxSize/2, y: buttonY - boxSize/2, w: boxSize, h: boxSize, choice: 2 }
            ];
            
            hoverChoice = -1;
            for(const box of choicesBoxes) {
                if(pos.x > box.x && pos.x < box.x + box.w && pos.y > box.y && pos.y < box.y + box.h) {
                    hoverChoice = box.choice;
                    break;
                }
            }
            
            if (hoverChoice !== -1) {
                document.body.style.cursor = 'pointer';
            } else {
                document.body.style.cursor = 'default';
            }
        }


        // --- INITIALIZATION ---
        window.addEventListener('resize', resizeCanvas, false);
        window.addEventListener('keydown', handleKeyDown);
        canvas.addEventListener('click', handleClick);
        canvas.addEventListener('mousemove', handleMouseMove);

        // Initial setup
        resizeCanvas();
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>