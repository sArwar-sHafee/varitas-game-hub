<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Spark 2</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(45deg, #1e3c72, #2a5298);
        }
        canvas {
            display: block;
            background: #0d1a26;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            border-radius: 15px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        class SoundEngine {
            constructor() {
                this.audioContext = null;
            }

            _init() {
                if (!this.audioContext) {
                    try {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    } catch (e) {
                        console.error("Web Audio API is not supported in this browser");
                    }
                }
            }
            
            playSound(type, duration = 0.1, frequency = 440, endFrequency = frequency) {
                this._init();
                if (!this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                if (frequency !== endFrequency) {
                    oscillator.frequency.exponentialRampToValueAtTime(endFrequency, this.audioContext.currentTime + duration);
                }

                gainNode.gain.setValueAtTime(1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            playFlip() {
                this.playSound('sine', 0.1, 800, 1200);
            }

            playMatch() {
                this.playSound('triangle', 0.2, 523.25, 1046.50);
                setTimeout(() => this.playSound('triangle', 0.3, 659.25, 1318.51), 100);
            }

            playMismatch() {
                this.playSound('square', 0.15, 220, 110);
            }

            playWin() {
                this.playSound('sine', 0.2, 587.33);
                setTimeout(() => this.playSound('sine', 0.2, 783.99), 150);
                setTimeout(() => this.playSound('sine', 0.4, 1174.66), 300);
            }

            playClick() {
                this.playSound('triangle', 0.08, 1000, 1200);
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 5 + 2;
                this.life = 1;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4 - 2;
            }

            update(deltaTime) {
                this.x += this.vx * (deltaTime * 60);
                this.y += this.vy * (deltaTime * 60);
                this.vy += 0.1 * (deltaTime * 60);
                this.life -= 0.02 * (deltaTime * 60);
                this.size *= 0.98;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Card {
            constructor(id, emoji, x, y, size) {
                this.id = id;
                this.emoji = emoji;
                this.x = x;
                this.y = y;
                this.width = size;
                this.height = size;
                this.isFlipped = false;
                this.isMatched = false;
                this.flipAngle = 0; // 0 to Math.PI
                this.scale = 1;
                this.targetScale = 1;
                this.isHovered = false;
            }

            update(deltaTime) {
                const flipSpeed = 0.2 * (deltaTime * 60);
                const scaleSpeed = 0.15 * (deltaTime * 60);

                if (this.isFlipped && this.flipAngle < Math.PI) {
                    this.flipAngle = Math.min(Math.PI, this.flipAngle + flipSpeed);
                } else if (!this.isFlipped && this.flipAngle > 0) {
                    this.flipAngle = Math.max(0, this.flipAngle - flipSpeed);
                }

                if (this.scale !== this.targetScale) {
                    this.scale += (this.targetScale - this.scale) * scaleSpeed;
                }
            }

            draw(ctx) {
                if (this.isMatched && this.scale < 0.1) return;

                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.scale(this.scale, this.scale);

                const currentAngle = this.flipAngle;
                const cosAngle = Math.cos(currentAngle);
                
                ctx.transform(cosAngle, 0, 0, 1, 0, 0);

                const isFront = currentAngle > Math.PI / 2;
                
                if (this.isHovered && !this.isFlipped && !this.isMatched) {
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.7)';
                    ctx.shadowBlur = 20;
                }

                if (isFront) {
                    this.drawFront(ctx);
                } else {
                    this.drawBack(ctx);
                }

                ctx.restore();
            }
            
            drawRoundedRect(ctx, w, h, r) {
                ctx.beginPath();
                ctx.moveTo(-w / 2 + r, -h / 2);
                ctx.arcTo(w / 2, -h / 2, w / 2, h / 2, r);
                ctx.arcTo(w / 2, h / 2, -w / 2, h / 2, r);
                ctx.arcTo(-w / 2, h / 2, -w / 2, -h / 2, r);
                ctx.arcTo(-w / 2, -h / 2, w / 2, -h / 2, r);
                ctx.closePath();
            }

            drawFront(ctx) {
                const w = this.width;
                const h = this.height;
                const r = w * 0.1;

                const gradient = ctx.createLinearGradient(-w/2, -h/2, w/2, h/2);
                gradient.addColorStop(0, '#f0f0f0');
                gradient.addColorStop(1, '#cccccc');
                ctx.fillStyle = gradient;

                this.drawRoundedRect(ctx, w, h, r);
                ctx.fill();

                ctx.save();
                ctx.scale(-1, 1); // Flip context back for text
                ctx.fillStyle = '#000';
                ctx.font = `${w * 0.6}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, h * 0.05);
                ctx.restore();
            }

            drawBack(ctx) {
                const w = this.width;
                const h = this.height;
                const r = w * 0.1;

                const gradient = ctx.createLinearGradient(-w/2, -h/2, w/2, h/2);
                gradient.addColorStop(0, '#3498db');
                gradient.addColorStop(1, '#2980b9');
                ctx.fillStyle = gradient;

                this.drawRoundedRect(ctx, w, h, r);
                ctx.fill();
                
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = w * 0.05;
                ctx.stroke();

                ctx.fillStyle = '#ecf0f1';
                ctx.font = `bold ${w * 0.25}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('M', 0, -h * 0.1);
                ctx.fillText('S', 0, h * 0.2);
            }

            isPointInside(px, py) {
                return px >= this.x && px <= this.x + this.width &&
                       py >= this.y && py <= this.y + this.height;
            }

            flip() {
                if (!this.isMatched) {
                    this.isFlipped = !this.isFlipped;
                }
            }
        }

        class Game {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.soundEngine = new SoundEngine();

                this.emojis = ['🍕', '🚀', '⭐', '🎈', '🍉', '🎁', '💎', '🎉'];
                this.gameState = 'START'; // START, PLAYING, GAME_OVER
                this.cards = [];
                this.flippedCards = [];
                this.score = 0;
                this.moves = 0;
                this.matchedPairs = 0;
                this.level = 1;
                this.totalPairs = 0;
                
                this.mouse = { x: 0, y: 0 };
                this.particles = [];
                
                this.lastTime = 0;
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                window.addEventListener('keydown', (e) => this.handleKeyDown(e));
                
                this.loop(0);
            }

            setupGame(level) {
                this.level = level;
                const pairCount = Math.min(this.emojis.length, 2 + level * 2);
                this.totalPairs = pairCount;

                const selectedEmojis = this.emojis.slice(0, pairCount);
                let cardEmojis = [...selectedEmojis, ...selectedEmojis];
                
                // Fisher-Yates shuffle
                for (let i = cardEmojis.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [cardEmojis[i], cardEmojis[j]] = [cardEmojis[j], cardEmojis[i]];
                }

                this.cards = [];
                const gridData = this.calculateGrid(cardEmojis.length);
                const { cols, rows, cardSize, paddingX, paddingY } = gridData;

                for (let i = 0; i < cardEmojis.length; i++) {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const x = paddingX + col * (cardSize + gridData.gap);
                    const y = paddingY + row * (cardSize + gridData.gap);
                    this.cards.push(new Card(i, cardEmojis[i], x, y, cardSize));
                }

                this.score = 0;
                this.moves = 0;
                this.matchedPairs = 0;
                this.flippedCards = [];
                this.gameState = 'PLAYING';
            }
            
            calculateGrid(numCards) {
                let cols, rows;
                const aspectRatio = (this.canvas.width / (window.devicePixelRatio || 1)) / (this.canvas.height / (window.devicePixelRatio || 1));

                if (aspectRatio > 1) { // Landscape
                    cols = Math.ceil(Math.sqrt(numCards * aspectRatio));
                    rows = Math.ceil(numCards / cols);
                } else { // Portrait
                    rows = Math.ceil(Math.sqrt(numCards / aspectRatio));
                    cols = Math.ceil(numCards / rows);
                }

                // Ensure we don't have an empty row/column if numCards is a product of two integers
                while (cols * (rows - 1) >= numCards) {
                    rows--;
                }
                while (rows * (cols - 1) >= numCards) {
                    cols--;
                }

                const logicalWidth = this.canvas.width / (window.devicePixelRatio || 1);
                const logicalHeight = this.canvas.height / (window.devicePixelRatio || 1);

                const gap = Math.min(logicalWidth, logicalHeight) * 0.02;
                const totalGapX = (cols - 1) * gap;
                const totalGapY = (rows - 1) * gap;
                
                const availableWidth = logicalWidth * 0.9;
                const availableHeight = logicalHeight * 0.7;

                const cardWidth = (availableWidth - totalGapX) / cols;
                const cardHeight = (availableHeight - totalGapY) / rows;
                const cardSize = Math.floor(Math.min(cardWidth, cardHeight));

                const totalGridWidth = cols * cardSize + totalGapX;
                const totalGridHeight = rows * cardSize + totalGapY;
                
                const paddingX = (logicalWidth - totalGridWidth) / 2;
                const paddingY = (logicalHeight - totalGridHeight) / 2 + logicalHeight * 0.1;

                return { cols, rows, cardSize, gap, paddingX, paddingY };
            }

            resize() {
                const dpr = window.devicePixelRatio || 1;
                
                const containerWidth = window.innerWidth;
                const containerHeight = window.innerHeight;
                
                let scale = Math.min(containerWidth / 1200, containerHeight / 800, 1);

                const canvasWidth = 1200 * scale;
                const canvasHeight = 800 * scale;

                this.canvas.style.width = `${canvasWidth}px`;
                this.canvas.style.height = `${canvasHeight}px`;

                this.canvas.width = 1200 * dpr;
                this.canvas.height = 800 * dpr;
                this.ctx.scale(dpr, dpr);
                
                if (this.gameState === 'PLAYING') {
                    const gridData = this.calculateGrid(this.cards.length);
                    this.cards.forEach((card, i) => {
                        const col = i % gridData.cols;
                        const row = Math.floor(i / gridData.cols);
                        card.x = gridData.paddingX + col * (gridData.cardSize + gridData.gap);
                        card.y = gridData.paddingY + row * (gridData.cardSize + gridData.gap);
                        card.width = card.height = gridData.cardSize;
                    });
                }
            }

            loop(timestamp) {
                const deltaTime = (timestamp - this.lastTime) / 1000;
                this.lastTime = timestamp;

                this.update(deltaTime || 0);
                this.draw();

                requestAnimationFrame((t) => this.loop(t));
            }

            update(deltaTime) {
                this.cards.forEach(card => card.update(deltaTime));
                
                this.particles.forEach((p, index) => {
                    p.update(deltaTime);
                    if (p.life <= 0) {
                        this.particles.splice(index, 1);
                    }
                });

                if (this.gameState === 'PLAYING' && this.cards.length > 0 && this.matchedPairs === this.totalPairs) {
                    this.gameState = 'GAME_OVER';
                    this.soundEngine.playWin();
                }
            }

            draw() {
                const logicalWidth = this.canvas.width / (window.devicePixelRatio || 1);
                const logicalHeight = this.canvas.height / (window.devicePixelRatio || 1);
                this.ctx.clearRect(0, 0, logicalWidth, logicalHeight);
                this.drawBackground();

                switch (this.gameState) {
                    case 'START':
                        this.drawStartScreen();
                        break;
                    case 'PLAYING':
                        this.drawGameScreen();
                        break;
                    case 'GAME_OVER':
                        this.drawGameOverScreen();
                        break;
                }
                
                this.particles.forEach(p => p.draw(this.ctx));
            }
            
            drawBackground() {
                const logicalWidth = this.canvas.width / (window.devicePixelRatio || 1);
                const logicalHeight = this.canvas.height / (window.devicePixelRatio || 1);
                const gradient = this.ctx.createRadialGradient(
                    logicalWidth / 2, logicalHeight / 2, 0,
                    logicalWidth / 2, logicalHeight / 2, Math.max(logicalWidth, logicalHeight)
                );
                gradient.addColorStop(0, '#1a2a3a');
                gradient.addColorStop(1, '#0d1a26');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, logicalWidth, logicalHeight);
            }

            drawStartScreen() {
                const logicalWidth = this.canvas.width / (window.devicePixelRatio || 1);
                const logicalHeight = this.canvas.height / (window.devicePixelRatio || 1);
                this.drawText('Mind Spark 2', logicalWidth / 2, logicalHeight * 0.25, 100, 'white', 'center', true);
                this.drawText('A modern memory game', logicalWidth / 2, logicalHeight * 0.35, 30, '#bdc3c7');

                const buttonWidth = 300;
                const buttonHeight = 70;
                const buttonX = logicalWidth / 2 - buttonWidth / 2;
                const buttonY = logicalHeight * 0.5;
                
                this.startButton = { x: buttonX, y: buttonY, width: buttonWidth, height: buttonHeight };
                const isHovering = this.isPointInRect(this.mouse.x, this.mouse.y, this.startButton);
                
                this.drawButton('START GAME', buttonX, buttonY, buttonWidth, buttonHeight, isHovering);

                this.drawText('Controls:', logicalWidth / 2, logicalHeight * 0.75, 24, '#bdc3c7');
                this.drawText('Mouse Click: Flip card / Select', logicalWidth / 2, logicalHeight * 0.8, 20, '#7f8c8d');
                this.drawText('Enter/Space: Start / Restart', logicalWidth / 2, logicalHeight * 0.85, 20, '#7f8c8d');
            }
            
            drawGameScreen() {
                this.cards.forEach(card => card.draw(this.ctx));
                this.drawHUD();
            }

            drawGameOverScreen() {
                const logicalWidth = this.canvas.width / (window.devicePixelRatio || 1);
                const logicalHeight = this.canvas.height / (window.devicePixelRatio || 1);
                this.drawGameScreen();
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, logicalWidth, logicalHeight);

                this.drawText('LEVEL COMPLETE!', logicalWidth / 2, logicalHeight * 0.3, 80, 'white', 'center', true);
                this.drawText(`Final Score: ${this.score}`, logicalWidth / 2, logicalHeight * 0.45, 40, '#2ecc71');
                this.drawText(`Moves: ${this.moves}`, logicalWidth / 2, logicalHeight * 0.52, 30, '#bdc3c7');

                const buttonWidth = 350;
                const buttonHeight = 70;
                const buttonX = logicalWidth / 2 - buttonWidth / 2;
                let buttonY = logicalHeight * 0.65;
                
                this.restartButton = { x: buttonX, y: buttonY, width: buttonWidth, height: buttonHeight };
                let isHovering = this.isPointInRect(this.mouse.x, this.mouse.y, this.restartButton);
                
                this.drawButton('PLAY AGAIN', buttonX, buttonY, buttonWidth, buttonHeight, isHovering);

                if (this.totalPairs < this.emojis.length) {
                    buttonY += buttonHeight + 20;
                    this.nextLevelButton = { x: buttonX, y: buttonY, width: buttonWidth, height: buttonHeight };
                    isHovering = this.isPointInRect(this.mouse.x, this.mouse.y, this.nextLevelButton);
                    this.drawButton('NEXT LEVEL', buttonX, buttonY, buttonWidth, buttonHeight, isHovering);
                } else {
                    this.nextLevelButton = null;
                }
            }

            drawHUD() {
                const logicalWidth = this.canvas.width / (window.devicePixelRatio || 1);
                const logicalHeight = this.canvas.height / (window.devicePixelRatio || 1);
                const hudY = logicalHeight * 0.07;
                this.drawText(`Score: ${this.score}`, logicalWidth * 0.1, hudY, 36, '#ecf0f1', 'left');
                this.drawText(`Level ${this.level}`, logicalWidth / 2, hudY, 36, '#ecf0f1', 'center');
                this.drawText(`Moves: ${this.moves}`, logicalWidth * 0.9, hudY, 36, '#ecf0f1', 'right');
            }

            drawText(text, x, y, size, color, align = 'center', isTitle = false) {
                this.ctx.fillStyle = color;
                if (isTitle) {
                    this.ctx.font = `bold ${size}px 'Segoe UI', 'Roboto', sans-serif`;
                    this.ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowOffsetX = 5;
                    this.ctx.shadowOffsetY = 5;
                } else {
                    this.ctx.font = `${size}px 'Segoe UI', 'Roboto', sans-serif`;
                }
                this.ctx.textAlign = align;
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(text, x, y);
                this.ctx.shadowColor = 'transparent';
                this.ctx.shadowBlur = 0;
                this.ctx.shadowOffsetX = 0;
                this.ctx.shadowOffsetY = 0;
            }

            drawButton(text, x, y, w, h, isHovering) {
                const r = h * 0.2;
                const gradient = this.ctx.createLinearGradient(x, y, x, y + h);
                if (isHovering) {
                    gradient.addColorStop(0, '#3aeabb');
                    gradient.addColorStop(1, '#2ecc71');
                    this.ctx.shadowColor = 'rgba(46, 204, 113, 0.7)';
                    this.ctx.shadowBlur = 15;
                } else {
                    gradient.addColorStop(0, '#3498db');
                    gradient.addColorStop(1, '#2980b9');
                    this.ctx.shadowColor = 'rgba(0,0,0,0.4)';
                    this.ctx.shadowBlur = 10;
                }
                
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.moveTo(x + r, y);
                this.ctx.arcTo(x + w, y, x + w, y + h, r);
                this.ctx.arcTo(x + w, y + h, x, y + h, r);
                this.ctx.arcTo(x, y + h, x, y, r);
                this.ctx.arcTo(x, y, x + w, y, r);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.shadowColor = 'transparent';
                this.ctx.shadowBlur = 0;

                this.drawText(text, x + w / 2, y + h / 2, h * 0.4, 'white');
            }

            handleClick(e) {
                this.soundEngine._init(); // Initialize on first user interaction
                const rect = this.canvas.getBoundingClientRect();
                const logicalWidth = this.canvas.width / (window.devicePixelRatio || 1);
                const logicalHeight = this.canvas.height / (window.devicePixelRatio || 1);
                const scaleX = logicalWidth / rect.width;
                const scaleY = logicalHeight / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                if (this.gameState === 'START') {
                    if (this.isPointInRect(x, y, this.startButton)) {
                        this.soundEngine.playClick();
                        this.setupGame(1);
                    }
                } else if (this.gameState === 'PLAYING') {
                    if (this.flippedCards.length < 2) {
                        for (const card of this.cards) {
                            if (!card.isFlipped && !card.isMatched && card.isPointInside(x, y)) {
                                card.flip();
                                this.soundEngine.playFlip();
                                this.flippedCards.push(card);
                                break;
                            }
                        }
                    }

                    if (this.flippedCards.length === 2) {
                        this.moves++;
                        const [card1, card2] = this.flippedCards;
                        if (card1.emoji === card2.emoji) {
                            this.handleMatch(card1, card2);
                        } else {
                            this.handleMismatch(card1, card2);
                        }
                    }
                } else if (this.gameState === 'GAME_OVER') {
                    if (this.isPointInRect(x, y, this.restartButton)) {
                        this.soundEngine.playClick();
                        this.setupGame(1);
                    } else if (this.nextLevelButton && this.isPointInRect(x, y, this.nextLevelButton)) {
                        this.soundEngine.playClick();
                        this.setupGame(this.level + 1);
                    }
                }
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const logicalWidth = this.canvas.width / (window.devicePixelRatio || 1);
                const logicalHeight = this.canvas.height / (window.devicePixelRatio || 1);
                const scaleX = logicalWidth / rect.width;
                const scaleY = logicalHeight / rect.height;
                this.mouse.x = (e.clientX - rect.left) * scaleX;
                this.mouse.y = (e.clientY - rect.top) * scaleY;
                
                this.cards.forEach(card => {
                    card.isHovered = card.isPointInside(this.mouse.x, this.mouse.y);
                });
            }
            
            handleKeyDown(e) {
                if (e.code === 'Enter' || e.code === 'Space') {
                    e.preventDefault();
                    if (this.gameState === 'START') {
                        this.soundEngine.playClick();
                        this.setupGame(1);
                    } else if (this.gameState === 'GAME_OVER') {
                        this.soundEngine.playClick();
                        this.setupGame(1);
                    }
                }
            }

            handleMatch(card1, card2) {
                card1.isMatched = true;
                card2.isMatched = true;
                this.matchedPairs++;
                this.score += 100;
                
                setTimeout(() => {
                    this.soundEngine.playMatch();
                    card1.targetScale = 1.2;
                    card2.targetScale = 1.2;
                    this.createParticles(card1.x + card1.width / 2, card1.y + card1.height / 2);
                    this.createParticles(card2.x + card2.width / 2, card2.y + card2.height / 2);
                    setTimeout(() => {
                        card1.targetScale = 0;
                        card2.targetScale = 0;
                    }, 300);
                }, 200);

                this.flippedCards = [];
            }

            handleMismatch(card1, card2) {
                this.score = Math.max(0, this.score - 10);
                setTimeout(() => {
                    this.soundEngine.playMismatch();
                    card1.flip();
                    card2.flip();
                    this.flippedCards = [];
                }, 1000);
            }
            
            isPointInRect(x, y, rect) {
                if (!rect) return false;
                return x >= rect.x && x <= rect.x + rect.width &&
                       y >= rect.y && y <= rect.y + rect.height;
            }

            createParticles(x, y) {
                const colors = ['#3498db', '#e74c3c', '#f1c40f', '#2ecc71', '#ecf0f1'];
                for (let i = 0; i < 30; i++) {
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    this.particles.push(new Particle(x, y, color));
                }
            }
        }

        window.onload = () => {
            new Game('gameCanvas');
        };
    </script>
</body>
</html>