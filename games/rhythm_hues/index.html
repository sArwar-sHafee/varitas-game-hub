<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Rhythm Hues</title>
    <style>
        :root {
            --bg-color: #12121a;
            --text-color: #f0f0f5;
            --glow-color: rgba(255, 255, 255, 0.1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Roboto', 'Helvetica', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: var(--bg-color);
            background-image: radial-gradient(circle at top left, rgba(88, 9, 121, 0.3), transparent 40%),
                              radial-gradient(circle at bottom right, rgba(0, 100, 255, 0.3), transparent 40%);
            color: var(--text-color);
            overflow: hidden;
            touch-action: none; /* Prevents pull-to-refresh and other gestures */
        }

        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            background-color: transparent;
            box-shadow: 0 0 30px 5px var(--glow-color);
            border-radius: 10px;
            max-width: 100%;
            max-height: 100%;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- GAME CONFIGURATION ---
        const CONFIG = {
            ASPECT_RATIO: 9 / 16,
            BASE_WIDTH: 450,
            COLORS: ['#ff3860', '#ffdd57', '#48c774', '#3273dc', '#8a4d76'],
            PLAYER: {
                HEIGHT: 25,
                Y_OFFSET: 50,
                CHANGE_ANIM_DURATION: 150, // ms
            },
            HUE: {
                SIZE: 20,
                START_SPEED: 150, // pixels per second
                SPAWN_INTERVAL: 1200, // ms
            },
            PARTICLE: {
                COUNT: 30,
                LIFESPAN: 1, // seconds
                SPEED: 200,
            },
            INITIAL_LIVES: 3,
            LEVEL_UP_SCORE: 10,
        };

        // --- GAME STATE ---
        let gameState = 'START'; // 'START', 'PLAYING', 'GAME_OVER'
        let score = 0;
        let lives = CONFIG.INITIAL_LIVES;
        let level = 1;
        let hueSpeed = CONFIG.HUE.START_SPEED;
        let hueSpawnInterval = CONFIG.HUE.SPAWN_INTERVAL;
        let lastHueSpawnTime = 0;
        let lastTime = 0;

        let player;
        let hues = [];
        let particles = [];
        let backgroundStars = [];
        
        let mousePos = { x: 0, y: 0 };
        let screenShake = { intensity: 0, duration: 0 };

        // --- AUDIO ---
        class SoundManager {
            constructor() {
                try {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn("Web Audio API is not supported in this browser");
                    this.audioCtx = null;
                }
            }
            
            resumeContext() {
                if (this.audioCtx && this.audioCtx.state === 'suspended') {
                    this.audioCtx.resume().catch(e => console.error("Audio context resume failed:", e));
                }
            }

            _play(freq, duration, type, volume = 0.3) {
                if (!this.audioCtx) return;
                const oscillator = this.audioCtx.createOscillator();
                const gainNode = this.audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioCtx.destination);
                
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(freq, this.audioCtx.currentTime);
                gainNode.gain.setValueAtTime(volume, this.audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioCtx.currentTime + duration);
                
                oscillator.start(this.audioCtx.currentTime);
                oscillator.stop(this.audioCtx.currentTime + duration);
            }

            match() { this._play(660, 0.1, 'sine', 0.4); this._play(880, 0.1, 'sine', 0.4); }
            miss() { this._play(160, 0.2, 'square', 0.5); }
            change() { this._play(440, 0.05, 'triangle', 0.2); }
            start() { this._play(220, 0.1, 'sawtooth'); this._play(440, 0.1, 'sawtooth');}
        }
        const sound = new SoundManager();

        // --- CLASSES ---
        class Player {
            constructor() {
                this.width = canvas.width * 0.8;
                this.height = CONFIG.PLAYER.HEIGHT;
                this.x = (canvas.width - this.width) / 2;
                this.y = canvas.height - CONFIG.PLAYER.Y_OFFSET - this.height / 2;
                this.colorIndex = 0;
                this.scale = 1;
                this.changeAnimStart = 0;
            }

            draw() {
                // Animate scale on color change
                if (this.changeAnimStart > 0) {
                    const elapsed = performance.now() - this.changeAnimStart;
                    if (elapsed < CONFIG.PLAYER.CHANGE_ANIM_DURATION) {
                        const progress = elapsed / CONFIG.PLAYER.CHANGE_ANIM_DURATION;
                        this.scale = 1 + 0.2 * Math.sin(progress * Math.PI);
                    } else {
                        this.scale = 1;
                        this.changeAnimStart = 0;
                    }
                }
                
                const w = this.width * this.scale;
                const h = this.height * this.scale;
                const x = this.x - (w - this.width) / 2;
                const y = this.y - (h - this.height) / 2;
                
                ctx.save();
                ctx.fillStyle = CONFIG.COLORS[this.colorIndex];
                ctx.shadowColor = CONFIG.COLORS[this.colorIndex];
                ctx.shadowBlur = 15;
                drawRoundRect(x, y, w, h, 10);
                ctx.fill();
                ctx.restore();
            }

            changeColor(direction) {
                sound.change();
                this.colorIndex = (this.colorIndex + direction + CONFIG.COLORS.length) % CONFIG.COLORS.length;
                this.changeAnimStart = performance.now();
            }
            
            resize() {
                this.width = canvas.width * 0.8;
                this.x = (canvas.width - this.width) / 2;
                this.y = canvas.height - CONFIG.PLAYER.Y_OFFSET - this.height / 2;
            }
        }

        class Hue {
            constructor() {
                this.size = CONFIG.HUE.SIZE * (canvas.width / CONFIG.BASE_WIDTH);
                this.x = Math.random() * (canvas.width - this.size * 2) + this.size;
                this.y = -this.size;
                this.colorIndex = Math.floor(Math.random() * CONFIG.COLORS.length);
                this.speed = hueSpeed;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 2;
            }

            update(deltaTime) {
                this.y += this.speed * deltaTime;
                this.rotation += this.rotationSpeed * deltaTime;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = CONFIG.COLORS[this.colorIndex];
                ctx.shadowColor = CONFIG.COLORS[this.colorIndex];
                ctx.shadowBlur = 10;
                ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 5 + 2;
                this.lifespan = CONFIG.PARTICLE.LIFESPAN;
                this.life = this.lifespan;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * CONFIG.PARTICLE.SPEED;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
            }

            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.life -= deltaTime;
            }

            draw() {
                const alpha = Math.max(0, this.life / this.lifespan);
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        class BackgroundStar {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 1.5 + 0.5;
                this.speed = Math.random() * 10 + 5;
            }
            
            update(deltaTime) {
                this.y += this.speed * deltaTime;
                if(this.y > canvas.height) {
                    this.y = 0;
                    this.x = Math.random() * canvas.width;
                }
            }
            
            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.size * 0.5})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- HELPER FUNCTIONS ---
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const { width, height } = container.getBoundingClientRect();
            
            let canvasWidth, canvasHeight;
            
            if (width / height > CONFIG.ASPECT_RATIO) {
                canvasHeight = height;
                canvasWidth = height * CONFIG.ASPECT_RATIO;
            } else {
                canvasWidth = width;
                canvasHeight = width / CONFIG.ASPECT_RATIO;
            }
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // Re-initialize or resize game elements
            if (player) player.resize();
            createBackgroundStars();
        }
        
        function createBackgroundStars() {
            backgroundStars = [];
            const starCount = Math.floor((canvas.width * canvas.height) / 4000);
            for(let i=0; i < starCount; i++) {
                backgroundStars.push(new BackgroundStar());
            }
        }

        function drawRoundRect(x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < CONFIG.PARTICLE.COUNT; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function triggerScreenShake(intensity, duration) {
            screenShake.intensity = intensity;
            screenShake.duration = duration;
        }

        function resetGame() {
            score = 0;
            lives = CONFIG.INITIAL_LIVES;
            level = 1;
            hueSpeed = CONFIG.HUE.START_SPEED;
            hueSpawnInterval = CONFIG.HUE.SPAWN_INTERVAL;
            hues = [];
            particles = [];
            player = new Player();
        }

        function startGame() {
            resetGame();
            gameState = 'PLAYING';
            sound.start();
        }
        
        // --- DRAW FUNCTIONS ---
        function drawBackground() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            backgroundStars.forEach(star => star.draw());
        }
        
        function drawUI() {
            ctx.fillStyle = 'white';
            ctx.font = `${canvas.width / 15}px 'Segoe UI', sans-serif`;
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 20, 40);

            ctx.textAlign = 'right';
            let hearts = '';
            for(let i=0; i<lives; i++) hearts += '❤️';
            ctx.fillText(hearts, canvas.width - 20, 40);
        }

        function drawText(text, x, y, size, color = 'white', align = 'center') {
            ctx.fillStyle = color;
            ctx.font = `bold ${size}px 'Segoe UI', sans-serif`;
            ctx.textAlign = align;
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 5;
            ctx.fillText(text, x, y);
            ctx.shadowBlur = 0;
        }

        function drawButton(text, x, y, width, height) {
            const isHovered = mousePos.x > x - width/2 && mousePos.x < x + width/2 &&
                              mousePos.y > y - height/2 && mousePos.y < y + height/2;
            
            ctx.save();
            ctx.fillStyle = isHovered ? '#48c774' : '#3273dc';
            ctx.shadowColor = isHovered ? '#48c774' : '#3273dc';
            ctx.shadowBlur = 15;
            drawRoundRect(x - width/2, y - height/2, width, height, 15);
            ctx.fill();
            ctx.restore();
            
            drawText(text, x, y + height / 4, height / 2);
            return { x, y, width, height };
        }
        
        function drawStartScreen() {
            drawBackground();
            
            const titleSize = canvas.width / 6;
            const grad = ctx.createLinearGradient(0, 0, canvas.width, 0);
            CONFIG.COLORS.forEach((color, i) => grad.addColorStop(i / CONFIG.COLORS.length, color));
            
            drawText('Rhythm', canvas.width / 2, canvas.height * 0.2, titleSize, grad);
            drawText('Hues', canvas.width / 2, canvas.height * 0.2 + titleSize, titleSize, grad);
            
            const instructionSize = canvas.width / 22;
            drawText('Match the falling hues!', canvas.width / 2, canvas.height * 0.45, instructionSize);
            
            const controlSize = canvas.width / 25;
            drawText('Controls:', canvas.width / 2, canvas.height * 0.55, controlSize, '#ffdd57');
            drawText('◀️ / ▶️ Arrow Keys', canvas.width / 2, canvas.height * 0.62, controlSize);
            drawText('A / D Keys', canvas.width / 2, canvas.height * 0.68, controlSize);
            drawText('Click / Tap Left or Right', canvas.width / 2, canvas.height * 0.74, controlSize);

            drawButton('▶ Play', canvas.width / 2, canvas.height * 0.88, canvas.width * 0.5, canvas.height * 0.08);
        }
        
        function drawGameOverScreen() {
            drawBackground();
            drawText('Game Over', canvas.width / 2, canvas.height * 0.3, canvas.width / 8, '#ff3860');
            drawText(`Final Score: ${score}`, canvas.width / 2, canvas.height * 0.45, canvas.width / 12);
            drawText(`You reached level ${level}!`, canvas.width / 2, canvas.height * 0.55, canvas.width / 18);
            
            drawButton('⟳ Restart', canvas.width / 2, canvas.height * 0.75, canvas.width * 0.6, canvas.height * 0.09);
        }


        // --- UPDATE FUNCTIONS ---
        function updateGame(deltaTime, timestamp) {
            // Spawn new hues
            if (timestamp - lastHueSpawnTime > hueSpawnInterval) {
                hues.push(new Hue());
                lastHueSpawnTime = timestamp;
            }

            // Update hues
            for (let i = hues.length - 1; i >= 0; i--) {
                const hue = hues[i];
                hue.update(deltaTime);

                // Collision detection
                if (hue.y + hue.size / 2 > player.y) {
                    if (hue.colorIndex === player.colorIndex) {
                        // Match
                        score++;
                        sound.match();
                        createParticles(hue.x, hue.y, CONFIG.COLORS[hue.colorIndex]);
                        
                        // Level up
                        if (score > 0 && score % CONFIG.LEVEL_UP_SCORE === 0) {
                            level++;
                            hueSpeed *= 1.1;
                            hueSpawnInterval *= 0.95;
                        }

                    } else {
                        // Miss
                        lives--;
                        sound.miss();
                        triggerScreenShake(10, 0.3);
                        if (lives <= 0) {
                            gameState = 'GAME_OVER';
                        }
                    }
                    hues.splice(i, 1);
                } else if (hue.y > canvas.height) {
                    // Missed off-screen
                    hues.splice(i, 1);
                }
            }
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update(deltaTime);
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Update background stars
            backgroundStars.forEach(star => star.update(deltaTime));

            // Update screen shake
            if (screenShake.duration > 0) {
                screenShake.duration -= deltaTime;
            } else {
                screenShake.intensity = 0;
            }
        }
        
        function drawGame() {
            drawBackground();
            particles.forEach(p => p.draw());
            player.draw();
            hues.forEach(hue => hue.draw());
            drawUI();
        }

        // --- MAIN GAME LOOP ---
        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            ctx.save();
            if (screenShake.intensity > 0) {
                const dx = (Math.random() - 0.5) * screenShake.intensity;
                const dy = (Math.random() - 0.5) * screenShake.intensity;
                ctx.translate(dx, dy);
            }

            switch (gameState) {
                case 'START':
                    drawStartScreen();
                    break;
                case 'PLAYING':
                    updateGame(deltaTime, timestamp);
                    drawGame();
                    break;
                case 'GAME_OVER':
                    drawGameOverScreen();
                    break;
            }
            
            ctx.restore();
            requestAnimationFrame(gameLoop);
        }

        // --- EVENT HANDLERS ---
        function handleKeyDown(e) {
            if (gameState !== 'PLAYING') return;

            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                player.changeColor(-1);
            } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                player.changeColor(1);
            }
        }
        
        function handlePointerDown(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = ((e.clientX || e.touches[0].clientX) - rect.left) * scaleX;
            const clickY = ((e.clientY || e.touches[0].clientY) - rect.top) * scaleY;

            if (gameState === 'START') {
                const btn = {x: canvas.width/2, y: canvas.height * 0.88, w: canvas.width * 0.5, h: canvas.height * 0.08};
                if (clickX > btn.x - btn.w/2 && clickX < btn.x + btn.w/2 && clickY > btn.y - btn.h/2 && clickY < btn.y + btn.h/2) {
                    sound.resumeContext();
                    startGame();
                }
            } else if (gameState === 'GAME_OVER') {
                const btn = {x: canvas.width/2, y: canvas.height * 0.75, w: canvas.width * 0.6, h: canvas.height * 0.09};
                if (clickX > btn.x - btn.w/2 && clickX < btn.x + btn.w/2 && clickY > btn.y - btn.h/2 && clickY < btn.y + btn.h/2) {
                    sound.resumeContext();
                    startGame();
                }
            } else if (gameState === 'PLAYING') {
                if (clickX < canvas.width / 2) {
                    player.changeColor(-1);
                } else {
                    player.changeColor(1);
                }
            }
        }
        
        function handleMouseMove(e) {
             const rect = canvas.getBoundingClientRect();
             const scaleX = canvas.width / rect.width;
             const scaleY = canvas.height / rect.height;
             mousePos.x = (e.clientX - rect.left) * scaleX;
             mousePos.y = (e.clientY - rect.top) * scaleY;
        }

        // --- INITIALIZATION ---
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('keydown', handleKeyDown);
        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('touchstart', handlePointerDown, { passive: false });
        canvas.addEventListener('mousemove', handleMouseMove);

        resizeCanvas();
        player = new Player(); // Initial player for start screen
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    });
    </script>
</body>
</html>