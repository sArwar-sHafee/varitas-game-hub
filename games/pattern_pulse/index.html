<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Pulse</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(circle at center, #2c3e50, #1a242d); /* Dark blue-grey gradient */
            color: #ecf0f1; /* Light text color */
        }
        canvas {
            display: block; /* Remove extra space below canvas */
            background-color: #333; /* Dark background for the game area */
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5), 0 0 15px rgba(0, 0, 0, 0.7); /* Neon glow effect */
            max-width: 90vw;
            max-height: 90vh;
            aspect-ratio: 1 / 1; /* Keep it square */
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // --- Game Constants and Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const GAME_STATES = {
            START: 'start',
            PLAYING_SEQUENCE: 'playing_sequence',
            WAITING_PLAYER_INPUT: 'waiting_player_input',
            GAME_OVER: 'game_over'
        };

        // Button properties (Order: Yellow, Red, Blue, Green for Q, W, A, S mapping)
        const BUTTON_COLORS = [
            '#FFFF00', // Yellow (Q - Top-Left)
            '#FF0000', // Red    (W - Top-Right)
            '#0000FF', // Blue   (A - Bottom-Left)
            '#00FF00'  // Green  (S - Bottom-Right)
        ];
        const BUTTON_HIGHLIGHT_COLORS = [
            '#FFFF66', // Yellow highlight
            '#FF6666', // Red highlight
            '#6666FF', // Blue highlight
            '#66FF66'  // Green highlight
        ];
        const BUTTON_FREQUENCIES = [
            523.25, // C5 for Yellow (Q)
            261.63, // C4 for Red (W)
            392.00, // G4 for Blue (A)
            329.63  // E4 for Green (S)
        ];
        const BUTTON_KEYS = ['q', 'w', 'a', 's']; // Mapped to Top-Left, Top-Right, Bottom-Left, Bottom-Right

        // Audio Context for Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let lastFrameTime = 0; // For requestAnimationFrame delta time, though not heavily used here

        // --- Utility Functions ---
        /**
         * Plays a simple programmatic sound using Web Audio API.
         * @param {number} frequency - The frequency of the sound in Hz.
         * @param {number} duration - The duration of the sound in seconds.
         */
        function playSound(frequency, duration) {
            if (!audioContext) return;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = 'sine'; // Sine wave for a clear tone
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            // Smooth attack and decay for better sound
            gainNode.gain.setValueAtTime(0.01, audioContext.currentTime); // Start quietly to avoid click
            gainNode.gain.exponentialRampToValueAtTime(0.5, audioContext.currentTime + duration * 0.1);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration + 0.1); // Stop slightly after fade out
        }

        // --- Button Class ---
        class GameButton {
            /**
             * Represents a single Simon Says button/quadrant.
             * @param {number} index - The index of the button (0-3).
             * @param {string} color - The base color of the button.
             * @param {string} highlightColor - The color when the button is lit.
             * @param {number} frequency - The sound frequency for this button.
             * @param {string} key - The keyboard key mapped to this button.
             */
            constructor(index, color, highlightColor, frequency, key) {
                this.index = index;
                this.baseColor = color;
                this.highlightColor = highlightColor;
                this.frequency = frequency;
                this.key = key;
                this.isLit = false;
                this.path = new Path2D(); // To store the button's shape for hit detection
            }

            /**
             * Draws the button on the canvas.
             * @param {CanvasRenderingContext2D} ctx - The 2D rendering context.
             * @param {number} centerX - X-coordinate of the game board center.
             * @param {number} centerY - Y-coordinate of the game board center.
             * @param {number} radius - Outer radius of the button.
             * @param {number} arcStartAngle - Starting angle of the arc in radians.
             * @param {number} arcEndAngle - Ending angle of the arc in radians.
             * @param {number} lineWidth - Width of the button border.
             */
            draw(ctx, centerX, centerY, radius, arcStartAngle, arcEndAngle, lineWidth) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, arcStartAngle, arcEndAngle);
                ctx.lineTo(centerX, centerY); // Connects to the center to form a pie slice
                ctx.closePath();
                
                // Store path for hit detection (needs to be updated on resize)
                this.path = new Path2D(ctx.currentPath);

                ctx.fillStyle = this.isLit ? this.highlightColor : this.baseColor;
                ctx.fill();

                ctx.strokeStyle = '#333'; // Dark border
                ctx.lineWidth = lineWidth;
                ctx.stroke();
                ctx.restore();
            }

            /**
             * Checks if a given point (e.g., mouse click) is within the button's area.
             * @param {number} x - X-coordinate of the point.
             * @param {number} y - Y-coordinate of the point.
             * @param {number} centerX - X-coordinate of the game board center.
             * @param {number} centerY - Y-coordinate of the game board center.
             * @param {number} innerRadius - Radius of the inner circle (center exclusion).
             * @returns {boolean} True if the point is in the button, false otherwise.
             */
            hitCheck(x, y, centerX, centerY, innerRadius) {
                // First check if point is within the arc path (including the center)
                if (ctx.isPointInPath(this.path, x, y)) {
                    // Then check if it's outside the inner circle to exclude the center
                    const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                    return dist > innerRadius;
                }
                return false;
            }

            /** Lights up the button and plays its sound. */
            press() {
                this.isLit = true;
                playSound(this.frequency, 0.2);
            }

            /** Turns off the button's light. */
            release() {
                this.isLit = false;
            }
        }

        // --- Game Class ---
        class PatternPulseGame {
            constructor() {
                this.buttons = [];
                for (let i = 0; i < 4; i++) {
                    this.buttons.push(new GameButton(
                        i,
                        BUTTON_COLORS[i],
                        BUTTON_HIGHLIGHT_COLORS[i],
                        BUTTON_FREQUENCIES[i],
                        BUTTON_KEYS[i]
                    ));
                }

                this.score = 0;
                this.sequence = [];       // The pattern to memorize
                this.playerSequence = []; // Player's input sequence
                this.gameState = GAME_STATES.START;

                this.sequenceIndex = 0;    // Current step in playing the sequence
                this.sequenceTimer = null; // Timer for sequence playback
                this.highlightDuration = 400; // ms button is lit during sequence playback
                this.pauseDuration = 100;    // ms pause between button lights

                this.message = ''; // On-screen message for player
                this.inputEnabled = false; // Flag to enable/disable player input
                this.audioResumed = false; // Flag to track if audioContext has been resumed

                this.initCanvas();
                this.setupEventListeners();
            }

            /** Initializes canvas dimensions and sets up resize handling. */
            initCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            /** Resizes the canvas and recalculates button positions/sizes based on window. */
            resizeCanvas() {
                const size = Math.min(window.innerWidth, window.innerHeight) * 0.8; // 80% of min dimension
                canvas.width = size;
                canvas.height = size;

                this.centerX = canvas.width / 2;
                this.centerY = canvas.height / 2;
                this.radius = canvas.width * 0.45; // Outer radius of the game board
                this.innerRadius = canvas.width * 0.25; // Inner radius of the game board
                this.lineWidth = canvas.width * 0.02; // Line width for button borders
            }

            /** Sets up event listeners for mouse and keyboard interactions. */
            setupEventListeners() {
                canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                document.addEventListener('mouseup', this.handleMouseUp.bind(this)); // Global mouseup for release
                document.addEventListener('keydown', this.handleKeyDown.bind(this));
                document.addEventListener('keyup', this.handleKeyUp.bind(this));
            }

            /** Resumes audio context on first user interaction. */
            resumeAudioContext() {
                if (!this.audioResumed) {
                    audioContext.resume().then(() => {
                        this.audioResumed = true;
                        console.log('AudioContext resumed!');
                    }).catch(e => console.error('Failed to resume AudioContext:', e));
                }
            }

            /** Handles mouse down events on the canvas. */
            handleMouseDown(event) {
                this.resumeAudioContext(); // Attempt to resume audio on any interaction

                if (this.gameState === GAME_STATES.START || this.gameState === GAME_STATES.GAME_OVER) {
                    this.startGame();
                    return;
                }

                if (!this.inputEnabled || this.gameState !== GAME_STATES.WAITING_PLAYER_INPUT) return;

                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                this.buttons.forEach((button, index) => {
                    if (button.hitCheck(mouseX, mouseY, this.centerX, this.centerY, this.innerRadius)) {
                        this.handleButtonPress(index);
                    }
                });
            }

            /** Handles global mouse up events to release buttons. */
            handleMouseUp() {
                if (!this.inputEnabled || this.gameState !== GAME_STATES.WAITING_PLAYER_INPUT) return;
                this.buttons.forEach(button => button.release());
            }

            /** Handles keyboard key down events. */
            handleKeyDown(event) {
                this.resumeAudioContext(); // Attempt to resume audio on any interaction

                if (this.gameState === GAME_STATES.START || this.gameState === GAME_STATES.GAME_OVER) {
                    if (event.code === 'Space') {
                        this.startGame();
                    }
                    return;
                }

                if (!this.inputEnabled || this.gameState !== GAME_STATES.WAITING_PLAYER_INPUT) return;

                const pressedKey = event.key.toLowerCase();
                this.buttons.forEach((button, index) => {
                    if (button.key === pressedKey && !button.isLit) { // Ensure button is not already lit
                        this.handleButtonPress(index);
                    }
                });
            }

            /** Handles keyboard key up events to release buttons. */
            handleKeyUp() {
                if (!this.inputEnabled || this.gameState !== GAME_STATES.WAITING_PLAYER_INPUT) return;
                this.buttons.forEach(button => button.release());
            }

            /**
             * Processes a button press, lighting it up and registering it in the player's sequence.
             * @param {number} buttonIndex - The index of the button that was pressed.
             */
            handleButtonPress(buttonIndex) {
                this.buttons[buttonIndex].press(); // Play sound and light up

                // Only register the input if the player hasn't completed their current sequence turn
                if (this.playerSequence.length < this.sequence.length) {
                    this.playerSequence.push(buttonIndex);
                    this.checkPlayerInput();
                }
            }

            /** Resets the game and starts a new round. */
            startGame() {
                this.score = 0;
                this.sequence = [];
                this.playerSequence = [];
                this.message = '';
                this.inputEnabled = false;
                this.generateSequenceStep(); // Start with one button in the sequence
                this.gameState = GAME_STATES.PLAYING_SEQUENCE;
                this.playSequence();
            }

            /**
             * Ends the game and displays the game over message.
             * @param {string} reason - The reason for game over (e.g., "Wrong pattern!").
             */
            gameOver(reason = '') {
                this.gameState = GAME_STATES.GAME_OVER;
                this.message = `Game Over! ${reason}\nScore: ${this.score} 🤯\nPress Space or Click to Restart`;
                playSound(100, 0.5); // Low frequency for game over feedback
                if (this.sequenceTimer) clearTimeout(this.sequenceTimer);
                this.buttons.forEach(button => button.release()); // Ensure all lights are off
            }

            /** Adds a new random button to the end of the current sequence. */
            generateSequenceStep() {
                const randomButtonIndex = Math.floor(Math.random() * this.buttons.length);
                this.sequence.push(randomButtonIndex);
            }

            /** Plays the current sequence visually and audibly to the player. */
            playSequence() {
                this.inputEnabled = false; // Disable input during sequence playback
                this.playerSequence = [];  // Reset player's input for the new round
                this.sequenceIndex = 0;
                this.message = `Round ${this.score + 1}`;

                if (this.sequenceTimer) clearTimeout(this.sequenceTimer); // Clear any existing timer

                const lightOffDelay = this.highlightDuration - this.pauseDuration;

                const playNext = () => {
                    if (this.sequenceIndex < this.sequence.length) {
                        const buttonToLight = this.buttons[this.sequence[this.sequenceIndex]];
                        buttonToLight.press();
                        setTimeout(() => buttonToLight.release(), lightOffDelay > 0 ? lightOffDelay : 0);

                        this.sequenceIndex++;
                        this.sequenceTimer = setTimeout(playNext, this.highlightDuration);
                    } else {
                        // Sequence finished playing, wait for player input
                        this.gameState = GAME_STATES.WAITING_PLAYER_INPUT;
                        this.message = 'Your turn! 🤔';
                        this.inputEnabled = true;
                    }
                };
                this.sequenceTimer = setTimeout(playNext, this.pauseDuration); // Initial delay before first light
            }

            /** Checks the player's most recent input against the pattern. */
            checkPlayerInput() {
                const currentInputIndex = this.playerSequence.length - 1;

                // Check if the latest input matches the sequence
                if (this.playerSequence[currentInputIndex] !== this.sequence[currentInputIndex]) {
                    this.gameOver('Wrong pattern!');
                    return;
                }

                // If the player has successfully repeated the entire current sequence
                if (this.playerSequence.length === this.sequence.length) {
                    this.score++;
                    this.message = `Correct! 🎉 Score: ${this.score}`;
                    playSound(600, 0.1); // High frequency for success feedback
                    this.inputEnabled = false; // Disable input while preparing next round
                    setTimeout(() => {
                        this.generateSequenceStep(); // Add a new step to the sequence
                        this.gameState = GAME_STATES.PLAYING_SEQUENCE;
                        this.playSequence(); // Play the new, longer sequence
                    }, 1000); // Wait a bit before playing the next sequence
                }
            }

            // --- Drawing Functions ---
            /** Draws all four game buttons on the canvas. */
            drawButtonLayout() {
                const arcAngle = Math.PI / 2; // Each button is a quarter circle
                // Mapping button index (0-3) to its specific quadrant angles
                // The order of buttons in the `this.buttons` array corresponds to (Q, W, A, S) or (Yellow, Red, Blue, Green)
                // Q (index 0) -> Top-Left, W (index 1) -> Top-Right, A (index 2) -> Bottom-Left, S (index 3) -> Bottom-Right
                const quadrantAngles = [
                    { start: 3 * arcAngle, end: 4 * arcAngle }, // Index 0 (Q) -> Top-Left
                    { start: 0, end: arcAngle },                 // Index 1 (W) -> Top-Right
                    { start: 2 * arcAngle, end: 3 * arcAngle },  // Index 2 (A) -> Bottom-Left
                    { start: arcAngle, end: 2 * arcAngle }       // Index 3 (S) -> Bottom-Right
                ];

                this.buttons.forEach((button, index) => {
                    const angles = quadrantAngles[index];
                    button.draw(ctx, this.centerX, this.centerY, this.radius, angles.start, angles.end, this.lineWidth);
                });

                // Draw center circle (background)
                ctx.beginPath();
                ctx.arc(this.centerX, this.centerY, this.innerRadius - this.lineWidth / 2, 0, Math.PI * 2);
                ctx.fillStyle = '#1a1a1a'; // Dark center
                ctx.fill();

                // Draw center circle (border)
                ctx.beginPath();
                ctx.arc(this.centerX, this.centerY, this.innerRadius, 0, Math.PI * 2);
                ctx.strokeStyle = '#333'; // Border color
                ctx.lineWidth = this.lineWidth;
                ctx.stroke();
            }

            /**
             * Draws multiline text centered on the canvas.
             * @param {string} text - The text to draw (can contain '\n' for new lines).
             * @param {number} fontSize - The font size in pixels.
             * @param {string} color - The color of the text.
             * @param {number} yOffset - Vertical offset from the center.
             */
            drawText(text, fontSize, color, yOffset = 0) {
                ctx.fillStyle = color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `${fontSize}px Arial, sans-serif`;

                const lines = text.split('\n');
                lines.forEach((line, index) => {
                    ctx.fillText(line, this.centerX, this.centerY + yOffset + (index - (lines.length - 1) / 2) * fontSize * 1.2);
                });
            }

            /** Main draw function, clears canvas and draws game elements based on state. */
            draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the entire canvas
                this.drawButtonLayout();

                switch (this.gameState) {
                    case GAME_STATES.START:
                        this.drawText('Pattern Pulse ✨', canvas.width * 0.08, '#00FFFF', -canvas.height * 0.15);
                        this.drawText('Memorize the pattern, then repeat it!\n\nUse Q, W, A, S keys or click the quadrants.\n\nPress Space or Click to Start', canvas.width * 0.035, '#ECF0F1', canvas.height * 0.05);
                        break;
                    case GAME_STATES.PLAYING_SEQUENCE:
                    case GAME_STATES.WAITING_PLAYER_INPUT:
                        this.drawText(this.message, canvas.width * 0.05, '#ECF0F1');
                        this.drawText(`Score: ${this.score}`, canvas.width * 0.03, '#BDC3C7', canvas.height * 0.1);
                        break;
                    case GAME_STATES.GAME_OVER:
                        this.drawText(this.message, canvas.width * 0.05, '#FF3333');
                        break;
                }
            }

            /** Main game loop, called via requestAnimationFrame. */
            loop(currentTime) {
                const deltaTime = currentTime - lastFrameTime;
                lastFrameTime = currentTime;

                // For this game, the primary logic is event/timer driven.
                // The loop primarily handles drawing.
                this.draw();
                requestAnimationFrame(this.loop.bind(this));
            }
        }

        // --- Initialize Game ---
        let game;
        window.onload = () => {
            game = new PatternPulseGame();
            game.loop(0); // Start the game loop
        };

    </script>
</body>
</html>