<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rift Rivals</title>
    <style>
        :root {
            --bg-color: #0d0c1d;
            --primary-color: #f72585;
            --secondary-color: #7209b7;
            --accent-color: #3a0ca3;
            --light-color: #ffffff;
            --font-family: 'Arial', 'Helvetica', sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--light-color);
            font-family: var(--font-family);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        canvas {
            background-color: #000;
            display: block;
            box-shadow: 0 0 30px rgba(72, 1, 255, 0.5);
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        // --- GAME SETUP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- AUDIO ENGINE ---
        class AudioEngine {
            constructor() {
                this.audioContext = null;
            }

            // Must be called after a user interaction
            init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            }

            // A helper to create and play a sound
            playSound({ type = 'sine', frequency = 440, duration = 0.1, volume = 0.5, attack = 0.01, decay = 0.01, release = 0.05, pitchBend = 0 }) {
                if (!this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                const now = this.audioContext.currentTime;
                const attackTime = now + attack;
                const decayTime = attackTime + decay;
                const endTime = now + duration;

                gainNode.connect(this.audioContext.destination);
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, attackTime);
                gainNode.gain.linearRampToValueAtTime(volume * 0.7, decayTime);
                gainNode.gain.linearRampToValueAtTime(0, endTime + release);

                oscillator.connect(gainNode);
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, now);

                if (pitchBend !== 0) {
                    oscillator.frequency.exponentialRampToValueAtTime(frequency + pitchBend, endTime);
                }

                oscillator.start(now);
                oscillator.stop(endTime + release);
            }

            jump() {
                this.playSound({ frequency: 400, duration: 0.05, volume: 0.2, pitchBend: 800, type: 'square' });
            }

            attack() {
                this.playSound({ frequency: 150, duration: 0.08, volume: 0.3, type: 'sawtooth', decay: 0.05 });
            }

            hit() {
                this.playSound({ frequency: 200, duration: 0.15, volume: 0.6, type: 'noise', attack: 0.001, decay: 0.1 });
                this.playSound({ frequency: 100, duration: 0.1, volume: 0.6, type: 'triangle', decay: 0.08 });
            }

            ko() {
                this.playSound({ frequency: 300, duration: 0.5, volume: 0.8, type: 'sawtooth', pitchBend: -280, release: 0.2 });
                this.playSound({ frequency: 100, duration: 0.6, volume: 0.8, type: 'noise', release: 0.3 });
            }
            
            uiClick() {
                this.init(); // Initialize audio context on first click
                this.playSound({ frequency: 600, duration: 0.05, volume: 0.3, type: 'sine', pitchBend: 200 });
            }
        }

        const audioEngine = new AudioEngine();
        
        // --- INPUT HANDLER ---
        class InputHandler {
            constructor() {
                this.keys = new Set();
                window.addEventListener('keydown', e => this.keys.add(e.code));
                window.addEventListener('keyup', e => this.keys.delete(e.code));
            }

            isDown(key) {
                return this.keys.has(key);
            }
        }

        // --- PARTICLE SYSTEM ---
        class Particle {
            constructor(x, y, color, size, life, velocity) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size;
                this.initialLife = life;
                this.life = life;
                this.velocity = velocity;
                this.gravity = 0.1;
            }

            update(deltaTime) {
                this.life -= deltaTime;
                this.velocity.y += this.gravity * (deltaTime / 16.67);
                this.x += this.velocity.x * (deltaTime / 16.67);
                this.y += this.velocity.y * (deltaTime / 16.67);
            }

            draw(ctx) {
                const alpha = Math.max(0, this.life / this.initialLife);
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // --- PLAYER CLASS ---
        class Player {
            constructor(game, x, y, color, character, controls) {
                this.game = game;
                this.startX = x;
                this.startY = y;
                this.x = x;
                this.y = y;
                this.width = 50;
                this.height = 70;
                this.color = color;
                this.character = character;
                this.controls = controls;

                this.vx = 0;
                this.vy = 0;
                this.speed = 7;
                this.jumpForce = 20;
                this.gravity = 1;

                this.isGrounded = false;
                this.jumpsLeft = 2;
                
                this.lives = 3;
                this.damage = 0;
                
                this.isAttacking = false;
                this.attackCooldown = 0;
                this.attackDuration = 150; // ms
                this.attackFrame = 0;
                this.hitbox = { x: 0, y: 0, width: 0, height: 0 };
                
                this.isInvincible = false;
                this.invincibilityDuration = 1000; // ms
                this.invincibilityTimer = 0;

                this.facingDirection = 1; // 1 for right, -1 for left
            }
            
            respawn() {
                this.x = this.startX;
                this.y = this.startY;
                this.vx = 0;
                this.vy = 0;
                this.damage = 0;
                this.isInvincible = true;
                this.invincibilityTimer = this.invincibilityDuration * 2; // Longer on respawn
            }

            update(deltaTime) {
                // Cooldowns
                if (this.attackCooldown > 0) this.attackCooldown -= deltaTime;
                if (this.invincibilityTimer > 0) this.invincibilityTimer -= deltaTime;
                else this.isInvincible = false;

                // --- Handle Input ---
                const input = this.game.inputHandler;
                // Left/Right movement
                if (input.isDown(this.controls.left)) {
                    this.vx = -this.speed;
                    this.facingDirection = -1;
                } else if (input.isDown(this.controls.right)) {
                    this.vx = this.speed;
                    this.facingDirection = 1;
                } else {
                    this.vx *= 0.8; // Friction
                }

                // Jump
                if (input.isDown(this.controls.jump) && this.jumpsLeft > 0) {
                   this.jump();
                   // Consume the key press to prevent multi-jumps per press
                   this.game.inputHandler.keys.delete(this.controls.jump);
                }

                // Attack
                if (input.isDown(this.controls.attack) && this.attackCooldown <= 0) {
                   this.attack();
                }

                // --- Physics ---
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;

                // --- Collision with platforms ---
                this.isGrounded = false;
                this.game.platforms.forEach(platform => {
                    // Check for vertical collision (landing on top)
                    if (this.y + this.height > platform.y && 
                        this.y + this.height < platform.y + 30 && // Only check top part of platform
                        this.x + this.width > platform.x && 
                        this.x < platform.x + platform.width &&
                        this.vy >= 0) 
                    {
                        this.y = platform.y - this.height;
                        this.vy = 0;
                        this.isGrounded = true;
                        this.jumpsLeft = 2;
                    }
                });

                // --- Attack Logic ---
                if (this.isAttacking) {
                    this.attackFrame += deltaTime;
                    if (this.attackFrame >= this.attackDuration) {
                        this.isAttacking = false;
                    }
                    // Update hitbox position
                    this.hitbox = {
                        x: this.x + (this.facingDirection === 1 ? this.width - 10 : -60),
                        y: this.y + this.height / 4,
                        width: 70,
                        height: 40
                    };
                }
            }
            
            jump() {
                this.vy = -this.jumpForce;
                this.jumpsLeft--;
                this.game.spawnParticles(this.x + this.width / 2, this.y + this.height, 10, '#ffffff', 3, Math.PI * 1.5, Math.PI / 4);
                audioEngine.jump();
            }
            
            attack() {
                this.isAttacking = true;
                this.attackFrame = 0;
                this.attackCooldown = 400; // ms
                audioEngine.attack();
            }
            
            takeHit(damage, knockback, direction) {
                if (this.isInvincible) return;
                
                this.damage += damage;
                this.vy = -knockback * (1 + this.damage / 100) * 0.7; // Vertical knockback
                this.vx = direction * knockback * (1 + this.damage / 100); // Horizontal knockback
                
                this.isInvincible = true;
                this.invincibilityTimer = this.invincibilityDuration;
                
                this.game.applyScreenShake(5, 150);
                this.game.spawnParticles(this.x + this.width/2, this.y + this.height/2, 20, '#ffcc00', 8);
                audioEngine.hit();
            }

            draw(ctx) {
                ctx.save();
                
                // Invincibility flash
                if(this.isInvincible && Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }
                
                // Player body (for collision visualization)
                // ctx.fillStyle = this.color;
                // ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Player character emoji
                ctx.font = `${this.height}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Flip character based on direction
                if(this.facingDirection === -1){
                    ctx.scale(-1, 1);
                    ctx.fillText(this.character, -(this.x + this.width / 2), this.y + this.height / 2);
                } else {
                    ctx.fillText(this.character, this.x + this.width / 2, this.y + this.height / 2);
                }
                ctx.restore();
                
                // Draw attack hitbox for debugging
                /*
                if (this.isAttacking) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.fillRect(this.hitbox.x, this.hitbox.y, this.hitbox.width, this.hitbox.height);
                }
                */
            }
        }
        
        // --- PLATFORM CLASS ---
        class Platform {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }

            draw(ctx) {
                const gradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(1, '#3a0ca3');
                ctx.fillStyle = gradient;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = '#f72585';
                ctx.lineWidth = 4;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
        }

        // --- GAME CLASS ---
        class Game {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;
                
                this.gameState = 'START'; // START, PLAYING, GAMEOVER
                this.inputHandler = new InputHandler();
                this.particles = [];
                this.stars = [];

                this.screenShake = { magnitude: 0, duration: 0, timer: 0 };
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                
                this.createStars();
                this.init();
            }
            
            init() {
                const p1Controls = { left: 'KeyA', right: 'KeyD', jump: 'KeyW', attack: 'KeyG' };
                const p2Controls = { left: 'ArrowLeft', right: 'ArrowRight', jump: 'ArrowUp', attack: 'ControlRight' };
                
                this.players = [
                    new Player(this, this.width * 0.2, this.height / 2, 'rgba(247, 37, 133, 0.8)', 'ðŸ¥·', p1Controls),
                    new Player(this, this.width * 0.8 - 50, this.height / 2, 'rgba(114, 9, 183, 0.8)', 'ðŸ¤–', p2Controls)
                ];

                this.platforms = [
                    new Platform(this.width / 2 - 250, this.height - 150, 500, 50, '#7209b7'),
                    new Platform(100, this.height - 350, 200, 30, '#7209b7'),
                    new Platform(this.width - 300, this.height - 350, 200, 30, '#7209b7')
                ];
                this.winner = null;
            }

            reset() {
                this.init();
                this.gameState = 'PLAYING';
            }
            
            resize() {
                const aspectRatio = 16 / 9;
                const vh = window.innerHeight;
                const vw = window.innerWidth;

                let newWidth, newHeight;

                if (vw / vh > aspectRatio) {
                    newHeight = vh * 0.9;
                    newWidth = newHeight * aspectRatio;
                } else {
                    newWidth = vw * 0.9;
                    newHeight = newWidth / aspectRatio;
                }

                this.canvas.width = newWidth;
                this.canvas.height = newHeight;
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                if (this.gameState !== 'START') this.init(); // Re-init on resize to reposition elements
            }
            
            createStars() {
                this.stars = [];
                for (let i = 0; i < 100; i++) {
                    this.stars.push({
                        x: Math.random() * this.width,
                        y: Math.random() * this.height,
                        size: Math.random() * 2 + 1,
                        speed: Math.random() * 0.5 + 0.1
                    });
                }
            }
            
            updateStars(deltaTime) {
                this.stars.forEach(star => {
                    star.y += star.speed * (deltaTime / 16.67);
                    if (star.y > this.height) {
                        star.y = 0;
                        star.x = Math.random() * this.width;
                    }
                });
            }

            spawnParticles(x, y, count, color, maxSpeed, angle = Math.PI * 2, spread = Math.PI * 2) {
                for (let i = 0; i < count; i++) {
                    const speed = Math.random() * maxSpeed;
                    const currentAngle = angle - spread / 2 + Math.random() * spread;
                    const velocity = {
                        x: Math.cos(currentAngle) * speed,
                        y: Math.sin(currentAngle) * speed
                    };
                    this.particles.push(new Particle(x, y, color, Math.random() * 3 + 1, Math.random() * 500 + 200, velocity));
                }
            }
            
            applyScreenShake(magnitude, duration) {
                this.screenShake.magnitude = magnitude;
                this.screenShake.duration = duration;
                this.screenShake.timer = duration;
            }
            
            update(deltaTime) {
                if (!deltaTime) return; // Skip first frame if deltaTime is NaN or 0
                
                this.updateStars(deltaTime);

                if (this.gameState !== 'PLAYING') return;

                // Update players and check collisions
                this.players.forEach(player => player.update(deltaTime));
                
                // Check for attacks
                const [p1, p2] = this.players;
                if (p1.isAttacking && this.checkAABB(p1.hitbox, p2)) {
                    p2.takeHit(8, 10, p1.facingDirection);
                    p1.isAttacking = false; // hit connects, end attack
                }
                if (p2.isAttacking && this.checkAABB(p2.hitbox, p1)) {
                    p1.takeHit(8, 10, p2.facingDirection);
                    p2.isAttacking = false;
                }

                // Check for out of bounds (KO)
                this.players.forEach((player, index) => {
                    if (player.y > this.height + 100 || player.x < -100 || player.x > this.width + 100) {
                        player.lives--;
                        audioEngine.ko();
                        this.applyScreenShake(15, 300);
                        this.spawnParticles(player.x, player.y, 50, player.color, 15);
                        if (player.lives > 0) {
                            player.respawn();
                        } else {
                            this.winner = this.players[1 - index];
                            this.gameState = 'GAMEOVER';
                        }
                    }
                });
                
                // Update particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.update(deltaTime);
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
                
                // Update screen shake
                if (this.screenShake.timer > 0) {
                    this.screenShake.timer -= deltaTime;
                } else {
                    this.screenShake.magnitude = 0;
                }
            }
            
            checkAABB(rect1, rect2) {
                // Ensure rect1 has dimensions before checking
                if (!rect1 || rect1.width === 0) return false;
                
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            draw() {
                this.ctx.save();
                // Screen shake
                if (this.screenShake.magnitude > 0) {
                    const dx = (Math.random() - 0.5) * this.screenShake.magnitude;
                    const dy = (Math.random() - 0.5) * this.screenShake.magnitude;
                    this.ctx.translate(dx, dy);
                }

                // Draw background
                const bgGradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
                bgGradient.addColorStop(0, '#0d0c1d');
                bgGradient.addColorStop(1, '#3a0ca3');
                this.ctx.fillStyle = bgGradient;
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // Draw stars
                this.ctx.fillStyle = 'white';
                this.stars.forEach(star => {
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.size / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                // Draw platforms
                this.platforms.forEach(p => p.draw(this.ctx));
                
                // Draw players
                if(this.players) this.players.forEach(p => p.draw(this.ctx));

                // Draw particles
                this.particles.forEach(p => p.draw(this.ctx));

                this.ctx.restore(); // Restore from screen shake
                
                // Draw UI
                this.drawUI();
            }
            
            drawUI() {
                if (this.gameState === 'START') {
                    this.drawStartScreen();
                } else if (this.gameState === 'PLAYING') {
                    this.drawGameUI();
                } else if (this.gameState === 'GAMEOVER') {
                    this.drawGameUI(); // Draw final state behind overlay
                    this.drawGameOverScreen();
                }
            }
            
            drawStartScreen() {
                // Dimmed overlay
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Title
                this.ctx.fillStyle = 'white';
                this.ctx.font = `bold ${this.width/10}px 'Arial', sans-serif`;
                this.ctx.textAlign = 'center';
                this.ctx.shadowColor = '#f72585';
                this.ctx.shadowBlur = 20;
                this.ctx.fillText('Rift Rivals', this.width / 2, this.height * 0.2);
                this.ctx.shadowBlur = 0;

                // Instructions
                const fontSize = this.width / 40;
                this.ctx.font = `bold ${fontSize}px 'Arial', sans-serif`;
                
                // Player 1
                this.ctx.fillStyle = this.players[0].color.replace('0.8', '1');
                this.ctx.fillText('Player 1: ðŸ¥·', this.width / 4, this.height * 0.4);
                this.ctx.font = `${fontSize * 0.8}px 'Arial', sans-serif`;
                this.ctx.fillStyle = 'white';
                this.ctx.fillText('Move: A, D', this.width / 4, this.height * 0.4 + 50);
                this.ctx.fillText('Jump: W', this.width / 4, this.height * 0.4 + 80);
                this.ctx.fillText('Attack: G', this.width / 4, this.height * 0.4 + 110);
                
                // Player 2
                this.ctx.fillStyle = this.players[1].color.replace('0.8', '1');
                this.ctx.font = `bold ${fontSize}px 'Arial', sans-serif`;
                this.ctx.fillText('Player 2: ðŸ¤–', this.width * 3 / 4, this.height * 0.4);
                this.ctx.font = `${fontSize * 0.8}px 'Arial', sans-serif`;
                this.ctx.fillStyle = 'white';
                this.ctx.fillText('Move: Arrow Keys', this.width * 3 / 4, this.height * 0.4 + 50);
                this.ctx.fillText('Jump: Arrow Up', this.width * 3 / 4, this.height * 0.4 + 80);
                this.ctx.fillText('Attack: Right CTRL', this.width * 3 / 4, this.height * 0.4 + 110);
                
                // Start Button
                this.startButton = { x: this.width/2 - 150, y: this.height * 0.75, width: 300, height: 70 };
                this.ctx.fillStyle = '#f72585';
                this.ctx.fillRect(this.startButton.x, this.startButton.y, this.startButton.width, this.startButton.height);
                this.ctx.fillStyle = 'white';
                this.ctx.font = `bold ${fontSize * 1.5}px 'Arial', sans-serif`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('START GAME', this.width / 2, this.height * 0.75 + 35);
            }
            
            drawGameUI() {
                const p1 = this.players[0];
                const p2 = this.players[1];
                
                // Player 1 UI
                this.drawPlayerInfo(p1, this.width * 0.05, this.height - 60, 'left');
                
                // Player 2 UI
                this.drawPlayerInfo(p2, this.width * 0.95, this.height - 60, 'right');
            }

            drawPlayerInfo(player, x, y, align) {
                const damageColor = `hsl(${Math.max(0, 100 - player.damage)}, 100%, 50%)`;
                
                this.ctx.textAlign = align;
                this.ctx.textBaseline = 'alphabetic';

                // Character and lives
                this.ctx.font = `${this.width / 30}px sans-serif`;
                let livesText = '';
                for(let i=0; i<player.lives; i++) livesText += player.character;
                this.ctx.fillStyle = 'white';
                this.ctx.fillText(livesText || "KO", x, y - 50);

                // Damage
                this.ctx.font = `bold ${this.width / 20}px 'Arial', sans-serif`;
                this.ctx.fillStyle = damageColor;
                this.ctx.strokeStyle = 'black';
                this.ctx.lineWidth = 4;
                this.ctx.strokeText(`${Math.floor(player.damage)}%`, x, y);
                this.ctx.fillText(`${Math.floor(player.damage)}%`, x, y);
            }
            
            drawGameOverScreen() {
                // Dimmed overlay
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Game Over Text
                this.ctx.fillStyle = 'white';
                this.ctx.font = `bold ${this.width/12}px 'Arial', sans-serif`;
                this.ctx.textAlign = 'center';
                this.ctx.shadowColor = '#7209b7';
                this.ctx.shadowBlur = 20;
                this.ctx.fillText('GAME OVER', this.width / 2, this.height * 0.3);
                
                // Winner Text
                const winnerCharacter = this.winner.character;
                this.ctx.font = `bold ${this.width/15}px 'Arial', sans-serif`;
                this.ctx.fillStyle = this.winner.color.replace('0.8', '1');
                this.ctx.fillText(`${winnerCharacter} Wins!`, this.width / 2, this.height * 0.5);
                this.ctx.shadowBlur = 0;
                
                // Restart Button
                this.restartButton = { x: this.width/2 - 150, y: this.height * 0.65, width: 300, height: 70 };
                this.ctx.fillStyle = '#7209b7';
                this.ctx.fillRect(this.restartButton.x, this.restartButton.y, this.restartButton.width, this.restartButton.height);
                this.ctx.fillStyle = 'white';
                this.ctx.font = `bold ${this.width/40}px 'Arial', sans-serif`;
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('PLAY AGAIN', this.width / 2, this.height * 0.65 + 35);
            }
            
            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;

                if (this.gameState === 'START' && this.startButton) {
                    if (mouseX > this.startButton.x && mouseX < this.startButton.x + this.startButton.width &&
                        mouseY > this.startButton.y && mouseY < this.startButton.y + this.startButton.height) {
                        audioEngine.uiClick();
                        this.gameState = 'PLAYING';
                    }
                } else if (this.gameState === 'GAMEOVER' && this.restartButton) {
                    if (mouseX > this.restartButton.x && mouseX < this.restartButton.x + this.restartButton.width &&
                        mouseY > this.restartButton.y && mouseY < this.restartButton.y + this.restartButton.height) {
                        audioEngine.uiClick();
                        this.reset();
                    }
                }
            }
        }

        // --- MAIN LOOP ---
        const game = new Game(canvas);
        let lastTime = 0;

        function animate(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            game.update(deltaTime);
            game.draw();
            
            requestAnimationFrame(animate);
        }

        animate(0);

    </script>
</body>
</html>