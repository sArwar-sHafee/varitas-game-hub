<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curve Fever</title>
    <style>
        :root {
            --bg-color-1: #1a0a24;
            --bg-color-2: #3a1a4a;
            --font-color: #f0f0f0;
            --accent-color: #ff3366;
            --glow-color: rgba(255, 51, 102, 0.7);
        }
        
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: radial-gradient(circle, var(--bg-color-2) 0%, var(--bg-color-1) 100%);
            color: var(--font-color);
            font-family: 'Segoe UI', 'Roboto', 'Helvetica', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            display: block;
            background: #00000022;
            border-radius: 10px;
            box-shadow: 0 0 30px var(--glow-color);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
    class AudioManager {
        constructor() {
            this.audioCtx = null;
        }

        _init() {
            if (!this.audioCtx) {
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            // Resume context on user gesture if needed
            if (this.audioCtx.state === 'suspended') {
                this.audioCtx.resume();
            }
        }

        play(type) {
            this._init();
            if (!this.audioCtx) return;

            const oscillator = this.audioCtx.createOscillator();
            const gainNode = this.audioCtx.createGain();
            gainNode.gain.setValueAtTime(0.2, this.audioCtx.currentTime);
            oscillator.connect(gainNode);
            gainNode.connect(this.audioCtx.destination);
            
            switch(type) {
                case 'eat':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(440, this.audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, this.audioCtx.currentTime + 0.3);
                    break;
                case 'gameOver':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(220, this.audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(55, this.audioCtx.currentTime + 0.5);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, this.audioCtx.currentTime + 0.5);
                    break;
                case 'start':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(261.63, this.audioCtx.currentTime); // C4
                    oscillator.frequency.linearRampToValueAtTime(523.25, this.audioCtx.currentTime + 0.1); // C5
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, this.audioCtx.currentTime + 0.2);
                    break;
            }

            oscillator.start();
            oscillator.stop(this.audioCtx.currentTime + 0.5);
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.size = Math.random() * 5 + 2;
            this.life = 1;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 4 + 1;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.05; // gravity
            this.life -= 0.02;
            this.size *= 0.98;
        }

        draw(ctx) {
            ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.life})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    class Snake {
        constructor(x, y, size, color) {
            this.body = [{x, y}];
            this.size = size;
            this.direction = { x: 1, y: 0 };
            this.nextDirection = { x: 1, y: 0 };
            this.baseColor = color;
            this.toGrow = 0;
        }
        
        changeDirection(x, y) {
            // Prevent 180-degree turns
            if (this.body.length > 1 && this.direction.x === -x && this.direction.y === -y) {
                return;
            }
            this.nextDirection = { x, y };
        }

        update() {
            this.direction = this.nextDirection;
            const head = this.body[0];
            const newHead = {
                x: head.x + this.direction.x,
                y: head.y + this.direction.y
            };
            this.body.unshift(newHead);

            if (this.toGrow > 0) {
                this.toGrow--;
            } else {
                this.body.pop();
            }
        }

        draw(ctx) {
            this.body.forEach((segment, index) => {
                const percent = index / this.body.length;
                const r = this.baseColor.r + (255 - this.baseColor.r) * percent;
                const g = this.baseColor.g + (180 - this.baseColor.g) * percent;
                const b = this.baseColor.b + (255 - this.baseColor.b) * percent;
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                
                const segSize = this.size * (1 - percent * 0.5);
                ctx.beginPath();
                ctx.arc(
                    (segment.x + 0.5) * this.size,
                    (segment.y + 0.5) * this.size,
                    segSize / 2, 0, Math.PI * 2
                );
                ctx.fill();
            });
        }

        grow() {
            this.toGrow += 3;
        }

        checkCollision(gridWidth, gridHeight) {
            const head = this.body[0];
            // Wall collision
            if (head.x < 0 || head.x >= gridWidth || head.y < 0 || head.y >= gridHeight) {
                return true;
            }
            // Self collision
            for (let i = 1; i < this.body.length; i++) {
                if (head.x === this.body[i].x && head.y === this.body[i].y) {
                    return true;
                }
            }
            return false;
        }
    }

    class Food {
        constructor(gridWidth, gridHeight, size) {
            this.gridWidth = gridWidth;
            this.gridHeight = gridHeight;
            this.size = size;
            this.pulse = 0;
            this.spawn([]);
        }

        spawn(snakeBody) {
            let validPosition = false;
            while (!validPosition) {
                this.x = Math.floor(Math.random() * this.gridWidth);
                this.y = Math.floor(Math.random() * this.gridHeight);
                validPosition = !snakeBody.some(seg => seg.x === this.x && seg.y === this.y);
            }
        }

        update(deltaTime) {
            this.pulse += deltaTime * 5;
        }

        draw(ctx) {
            const scale = 1 + Math.sin(this.pulse) * 0.1;
            ctx.font = `${this.size * scale}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('🍎', (this.x + 0.5) * this.size, (this.y + 0.5) * this.size);
        }
    }

    class Game {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.audio = new AudioManager();
            
            this.gameState = 'START'; // START, PLAYING, GAME_OVER
            this.GRID_SIZE = 20;
            this.score = 0;
            this.particles = [];
            
            this.lastTime = 0;
            this.moveTimer = 0;
            this.moveInterval = 0.1; // seconds

            this.mousePos = { x: 0, y: 0 };

            window.addEventListener('resize', this.resize.bind(this));
            this.resize();
            this.initListeners();

            requestAnimationFrame(this.gameLoop.bind(this));
        }
        
        resize() {
            const aspectRatio = 16 / 9;
            let newWidth = window.innerWidth;
            let newHeight = window.innerHeight;
            
            if (newWidth / newHeight > aspectRatio) {
                newWidth = newHeight * aspectRatio;
            } else {
                newHeight = newWidth / aspectRatio;
            }
            
            this.canvas.width = Math.min(newWidth, 1280);
            this.canvas.height = Math.min(newHeight, 720);

            this.gridWidth = Math.floor(this.canvas.width / this.GRID_SIZE);
            this.gridHeight = Math.floor(this.canvas.height / this.GRID_SIZE);

            if (this.gameState !== 'START') {
                this.reset();
            }
        }

        initListeners() {
            document.addEventListener('keydown', this.handleKeyDown.bind(this));
            this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
            this.canvas.addEventListener('mousedown', this.handleClick.bind(this));
            this.canvas.addEventListener('touchstart', (e) => this.handleClick(e.touches[0]));
            this.canvas.addEventListener('touchmove', (e) => this.handleMouseMove(e.touches[0]));
        }

        handleKeyDown(e) {
            if (this.gameState !== 'PLAYING') return;
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    this.snake.changeDirection(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                    this.snake.changeDirection(0, 1);
                    break;
                case 'ArrowLeft':
                case 'a':
                    this.snake.changeDirection(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                    this.snake.changeDirection(1, 0);
                    break;
            }
        }
        
        handleMouseMove(e) {
            if (this.gameState !== 'PLAYING') return;

            const rect = this.canvas.getBoundingClientRect();
            this.mousePos.x = (e.clientX - rect.left) / this.GRID_SIZE;
            this.mousePos.y = (e.clientY - rect.top) / this.GRID_SIZE;

            const head = this.snake.body[0];
            const dx = this.mousePos.x - (head.x + 0.5);
            const dy = this.mousePos.y - (head.y + 0.5);

            if (Math.abs(dx) > Math.abs(dy)) {
                this.snake.changeDirection(dx > 0 ? 1 : -1, 0);
            } else {
                this.snake.changeDirection(0, dy > 0 ? 1 : -1);
            }
        }
        
        handleClick() {
            if (this.gameState === 'START' || this.gameState === 'GAME_OVER') {
                this.startGame();
            }
        }

        reset() {
            const startX = Math.floor(this.gridWidth / 4);
            const startY = Math.floor(this.gridHeight / 2);
            const snakeColor = { r: 50, g: 200, b: 100 };
            
            this.snake = new Snake(startX, startY, this.GRID_SIZE, snakeColor);
            this.food = new Food(this.gridWidth, this.gridHeight, this.GRID_SIZE);
            this.score = 0;
            this.moveInterval = 0.1;
            this.particles = [];
        }

        startGame() {
            this.reset();
            this.gameState = 'PLAYING';
            this.audio.play('start');
        }

        gameOver() {
            this.gameState = 'GAME_OVER';
            this.audio.play('gameOver');
        }
        
        createExplosion(x, y) {
            for (let i = 0; i < 30; i++) {
                this.particles.push(new Particle(x, y, { r: 255, g: 80, b: 80 }));
            }
        }

        gameLoop(timestamp) {
            const deltaTime = (timestamp - this.lastTime) / 1000;
            this.lastTime = timestamp;

            this.update(deltaTime);
            this.draw();

            requestAnimationFrame(this.gameLoop.bind(this));
        }

        update(deltaTime) {
            this.particles.forEach((p, i) => {
                p.update();
                if (p.life <= 0) this.particles.splice(i, 1);
            });
            
            if (this.gameState === 'PLAYING') {
                this.moveTimer += deltaTime;
                if (this.moveTimer >= this.moveInterval) {
                    this.moveTimer = 0;
                    this.snake.update();
                    
                    if (this.snake.checkCollision(this.gridWidth, this.gridHeight)) {
                        this.gameOver();
                        return;
                    }

                    // Check for food collision
                    const head = this.snake.body[0];
                    if (head.x === this.food.x && head.y === this.food.y) {
                        this.snake.grow();
                        this.score++;
                        this.moveInterval = Math.max(0.04, this.moveInterval * 0.98); // Speed up
                        this.food.spawn(this.snake.body);
                        this.audio.play('eat');
                        this.createExplosion(
                            (this.food.x + 0.5) * this.GRID_SIZE, 
                            (this.food.y + 0.5) * this.GRID_SIZE
                        );
                    }
                }
                this.food.update(deltaTime);
            }
        }

        draw() {
            // Clear canvas with a transparent overlay for motion blur effect
            this.ctx.fillStyle = 'rgba(26, 10, 36, 0.4)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            this.particles.forEach(p => p.draw(this.ctx));

            if (this.gameState === 'PLAYING') {
                this.food.draw(this.ctx);
                this.snake.draw(this.ctx);
                this.drawScore();
            } else if (this.gameState === 'START') {
                this.drawStartScreen();
            } else if (this.gameState === 'GAME_OVER') {
                this.drawGameOverScreen();
            }
        }

        drawScore() {
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            this.ctx.font = '24px sans-serif';
            this.ctx.textAlign = 'left';
            this.ctx.textBaseline = 'top';
            this.ctx.fillText(`Score: ${this.score}`, 10, 10);
        }

        drawCenteredText(text, y, size, color) {
            this.ctx.fillStyle = color;
            this.ctx.font = `${size}px sans-serif`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.shadowColor = 'var(--glow-color)';
            this.ctx.shadowBlur = 15;
            this.ctx.fillText(text, this.canvas.width / 2, y);
            this.ctx.shadowBlur = 0;
        }

        drawStartScreen() {
            this.drawCenteredText('🐍 Curve Fever', this.canvas.height / 2 - 120, 60, '#fff');
            
            this.ctx.font = '20px sans-serif';
            this.ctx.fillStyle = '#ccc';
            this.ctx.fillText('Controls:', this.canvas.width / 2, this.canvas.height / 2 - 40);
            this.ctx.fillText('Keyboard: Arrow Keys or WASD', this.canvas.width / 2, this.canvas.height / 2 - 10);
            this.ctx.fillText('Mouse/Touch: Guide the snake', this.canvas.width / 2, this.canvas.height / 2 + 20);

            this.drawCenteredText('Click or Tap to Start', this.canvas.height / 2 + 100, 30, 'var(--accent-color)');
        }

        drawGameOverScreen() {
            this.drawCenteredText('Game Over', this.canvas.height / 2 - 80, 60, '#fff');
            this.drawCenteredText(`Final Score: ${this.score}`, this.canvas.height / 2, 40, '#fff');
            this.drawCenteredText('Click or Tap to Restart', this.canvas.height / 2 + 80, 30, 'var(--accent-color)');
        }
    }

    const canvas = document.getElementById('gameCanvas');
    new Game(canvas);

    </script>
</body>
</html>