<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spire Scramble</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 90vmin;
            max-height: 90vmin;
        }
        canvas {
            background-color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            border: 2px solid #0ff;
            border-radius: 8px;
            width: 100%;
            height: auto;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

<script>
// =============================================================================
// GAME SETUP & CONSTANTS
// =============================================================================
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');

const TILE_SIZE = 32;
const MAP_WIDTH = 25;
const MAP_HEIGHT = 25;

canvas.width = TILE_SIZE * MAP_WIDTH;
canvas.height = TILE_SIZE * MAP_HEIGHT;

const GameState = {
    START_SCREEN: 'START_SCREEN',
    PLAYING: 'PLAYING',
    GAME_OVER: 'GAME_OVER',
};

const COLORS = {
    WALL: '#334',
    WALL_LIT: '#557',
    FLOOR: '#223',
    FLOOR_LIT: '#446',
    PLAYER: '#0f0',
    ENEMY: '#f00',
    ITEM: '#ff0',
    STAIRS: '#0ff',
    PARTICLE: ['#ff0', '#f80', '#f00'],
    UI_TEXT: '#eee',
    UI_BG: 'rgba(0, 0, 0, 0.5)',
};

const EMOJIS = {
    PLAYER: '🤺',
    STAIRS: '🪜',
    WALL: '🧱',
    ENEMIES: ['👹', '👻', '💀', '🐍', '🕷️'],
    ITEMS: {
        HEALTH: '❤️',
        SWORD: '🗡️',
        SHIELD: '🛡️',
    }
};


// =============================================================================
// AUDIO ENGINE
// =============================================================================
class AudioEngine {
    constructor() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.sounds = {
            move: this.createSound(100, 0.05, 'square', 0.1, 0),
            hit: this.createSound(150, 0.2, 'sawtooth', 0.2, 0.1),
            pickup: this.createSound(500, 0.1, 'sine', 0.2, 0, 800),
            descend: this.createSound(800, 0.3, 'triangle', 0.5, 0, 400),
            gameOver: this.createSound(400, 0.8, 'sawtooth', 1, 0, 100),
            enemyHit: this.createSound(80, 0.15, 'square', 0.2, 0.1),
        };
    }

    createSound(startFreq, duration, type, volume, attackTime, endFreq = startFreq) {
        return () => {
            if (!this.audioContext) return;
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(startFreq, this.audioContext.currentTime);
            oscillator.frequency.linearRampToValueAtTime(endFreq, this.audioContext.currentTime + duration);

            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, this.audioContext.currentTime + attackTime);
            gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            oscillator.start();
            oscillator.stop(this.audioContext.currentTime + duration);
        };
    }

    play(soundName) {
        if (this.sounds[soundName]) {
            this.sounds[soundName]();
        }
    }
}


// =============================================================================
// PARTICLE SYSTEM
// =============================================================================
class Particle {
    constructor(x, y, color, size, speed, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = size;
        this.life = life;
        this.initialLife = life;
        this.vx = (Math.random() - 0.5) * speed;
        this.vy = (Math.random() - 0.5) * speed;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life / this.initialLife;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1;
    }
}

class ParticleSystem {
    constructor() {
        this.particles = [];
    }

    emit(x, y, color, count = 10, size = 3, speed = 2, life = 30) {
        for (let i = 0; i < count; i++) {
            this.particles.push(new Particle(x, y, color, Math.random() * size + 1, speed, Math.random() * life + 10));
        }
    }

    update() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update();
            if (this.particles[i].life <= 0) {
                this.particles.splice(i, 1);
            }
        }
    }

    draw(ctx) {
        this.particles.forEach(p => p.draw(ctx));
    }
}


// =============================================================================
// ENTITY CLASSES
// =============================================================================
class Entity {
    constructor(x, y, emoji, color, name) {
        this.x = x;
        this.y = y;
        this.emoji = emoji;
        this.color = color;
        this.name = name;
        this.isAnimating = false;
        this.animX = x * TILE_SIZE;
        this.animY = y * TILE_SIZE;
    }

    updateAnimation(speed = 0.1) {
        const targetX = this.x * TILE_SIZE;
        const targetY = this.y * TILE_SIZE;
        
        if (Math.abs(this.animX - targetX) < 0.5 && Math.abs(this.animY - targetY) < 0.5) {
            this.animX = targetX;
            this.animY = targetY;
            this.isAnimating = false;
        } else {
            this.isAnimating = true;
            this.animX += (targetX - this.animX) * speed;
            this.animY += (targetY - this.animY) * speed;
        }
    }

    draw(ctx, tileSize) {
        ctx.font = `${tileSize * 0.8}px monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.emoji, this.animX + tileSize / 2, this.animY + tileSize / 2);
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, EMOJIS.PLAYER, COLORS.PLAYER, 'Player');
        this.maxHp = 30;
        this.hp = this.maxHp;
        this.atk = 5;
        this.def = 2;
    }

    heal(amount) {
        this.hp = Math.min(this.maxHp, this.hp + amount);
    }
}

class Enemy extends Entity {
    constructor(x, y, floor) {
        const typeIndex = Math.floor(Math.random() * EMOJIS.ENEMIES.length);
        const name = ['Ogre', 'Ghost', 'Skeleton', 'Snake', 'Spider'][typeIndex];
        super(x, y, EMOJIS.ENEMIES[typeIndex], COLORS.ENEMY, name);

        this.maxHp = 10 + floor * 3;
        this.hp = this.maxHp;
        this.atk = 3 + floor * 2;
        this.def = 1 + floor;
    }
}

class Item extends Entity {
    constructor(x, y, type) {
        const itemData = {
            'HEALTH': { emoji: EMOJIS.ITEMS.HEALTH, name: 'Health Potion' },
            'SWORD': { emoji: EMOJIS.ITEMS.SWORD, name: 'Sword' },
            'SHIELD': { emoji: EMOJIS.ITEMS.SHIELD, name: 'Shield' }
        };
        super(x, y, itemData[type].emoji, COLORS.ITEM, itemData[type].name);
        this.type = type;
    }
}


// =============================================================================
// MAP CLASS
// =============================================================================
class Map {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.tiles = [];
        this.rooms = [];
        this.fov = [];
        this.visible = [];
    }

    generate() {
        this.tiles = Array(this.height).fill(null).map(() => Array(this.width).fill(1)); // 1 = wall
        this.rooms = [];
        const maxRooms = 15;
        const minRoomSize = 3;
        const maxRoomSize = 7;

        for (let i = 0; i < maxRooms; i++) {
            const w = Math.floor(Math.random() * (maxRoomSize - minRoomSize + 1)) + minRoomSize;
            const h = Math.floor(Math.random() * (maxRoomSize - minRoomSize + 1)) + minRoomSize;
            const x = Math.floor(Math.random() * (this.width - w - 1)) + 1;
            const y = Math.floor(Math.random() * (this.height - h - 1)) + 1;

            const newRoom = { x, y, w, h };
            let overlaps = false;
            for (const otherRoom of this.rooms) {
                if (x < otherRoom.x + otherRoom.w && x + w > otherRoom.x &&
                    y < otherRoom.y + otherRoom.h && y + h > otherRoom.y) {
                    overlaps = true;
                    break;
                }
            }
            if (!overlaps) {
                this.createRoom(newRoom);
                if (this.rooms.length > 0) {
                    const prevRoom = this.rooms[this.rooms.length - 1];
                    this.createCorridor(prevRoom, newRoom);
                }
                this.rooms.push(newRoom);
            }
        }
        
        // Setup FOV map
        this.fov = Array(this.height).fill(null).map(() => Array(this.width).fill(false));
    }

    createRoom(room) {
        for (let y = room.y; y < room.y + room.h; y++) {
            for (let x = room.x; x < room.x + room.w; x++) {
                this.tiles[y][x] = 0; // 0 = floor
            }
        }
    }

    createCorridor(room1, room2) {
        const x1 = room1.x + Math.floor(room1.w / 2);
        const y1 = room1.y + Math.floor(room1.h / 2);
        const x2 = room2.x + Math.floor(room2.w / 2);
        const y2 = room2.y + Math.floor(room2.h / 2);

        if (Math.random() < 0.5) {
            this.createHTunnel(x1, x2, y1);
            this.createVTunnel(y1, y2, x2);
        } else {
            this.createVTunnel(y1, y2, x1);
            this.createHTunnel(x1, x2, y2);
        }
    }

    createHTunnel(x1, x2, y) {
        for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
            this.tiles[y][x] = 0;
        }
    }

    createVTunnel(y1, y2, x) {
        for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
            this.tiles[y][x] = 0;
        }
    }

    isWall(x, y) {
        return this.tiles[y][x] === 1;
    }

    getEmptyTile() {
        let x, y;
        do {
            const room = this.rooms[Math.floor(Math.random() * this.rooms.length)];
            x = room.x + Math.floor(Math.random() * room.w);
            y = room.y + Math.floor(Math.random() * room.h);
        } while (this.isWall(x, y));
        return { x, y };
    }
    
    computeFov(playerX, playerY, radius) {
        this.visible = Array(this.height).fill(null).map(() => Array(this.width).fill(false));
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                const dx = x - playerX;
                const dy = y - playerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= radius) {
                    this.castRay(playerX, playerY, x, y);
                }
            }
        }
    }

    castRay(x0, y0, x1, y1) {
        const dx = Math.abs(x1 - x0);
        const dy = -Math.abs(y1 - y0);
        let sx = x0 < x1 ? 1 : -1;
        let sy = y0 < y1 ? 1 : -1;
        let err = dx + dy;

        while (true) {
            if (y0 < 0 || y0 >= this.height || x0 < 0 || x0 >= this.width) break;

            this.visible[y0][x0] = true;
            this.fov[y0][x0] = true;

            if (this.isWall(x0, y0)) {
                break;
            }
            if (x0 === x1 && y0 === y1) {
                break;
            }
            let e2 = 2 * err;
            if (e2 >= dy) {
                err += dy;
                x0 += sx;
            }
            if (e2 <= dx) {
                err += dx;
                y0 += sy;
            }
        }
    }

    draw(ctx, tileSize) {
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                const isVisible = this.visible[y][x];
                const isExplored = this.fov[y][x];

                if (!isVisible && !isExplored) continue;

                let color;
                if (this.isWall(x, y)) {
                    color = isVisible ? COLORS.WALL_LIT : COLORS.WALL;
                } else {
                    color = isVisible ? COLORS.FLOOR_LIT : COLORS.FLOOR;
                }
                ctx.fillStyle = color;
                ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
            }
        }
    }
}


// =============================================================================
// MAIN GAME CLASS
// =============================================================================
class Game {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.gameState = GameState.START_SCREEN;
        this.audioEngine = new AudioEngine();
        this.particleSystem = new ParticleSystem();
        this.messages = [];
        this.screenShake = 0;

        this.init();
    }

    init() {
        this.lastTime = 0;
        this.animationTimer = 0;
        this.isAnimating = false;
        
        window.addEventListener('keydown', (e) => this.handleInput(e));
        
        this.reset();
        this.gameLoop(0);
    }
    
    reset() {
        this.floor = 1;
        this.player = new Player(0, 0);
        this.generateLevel();
        this.messages = [];
        this.addMessage("Welcome to Spire Scramble!", "#0ff");
        this.addMessage("Use Arrow Keys or WASD to move.", "#0ff");
    }

    startGame() {
        this.gameState = GameState.PLAYING;
        this.reset();
    }

    generateLevel() {
        this.map = new Map(MAP_WIDTH, MAP_HEIGHT);
        this.map.generate();

        const playerStart = this.map.getEmptyTile();
        this.player.x = playerStart.x;
        this.player.y = playerStart.y;
        this.player.animX = this.player.x * TILE_SIZE;
        this.player.animY = this.player.y * TILE_SIZE;

        this.entities = [this.player];
        this.items = [];
        
        const numEnemies = Math.floor(this.floor * 1.5) + 2;
        for (let i = 0; i < numEnemies; i++) {
            const pos = this.map.getEmptyTile();
            if (!this.getEntityAt(pos.x, pos.y)) {
                this.entities.push(new Enemy(pos.x, pos.y, this.floor));
            }
        }

        const numItems = Math.floor(Math.random() * 3) + 1;
        for (let i = 0; i < numItems; i++) {
            const pos = this.map.getEmptyTile();
            if (!this.getEntityAt(pos.x, pos.y) && !this.items.find(it => it.x === pos.x && it.y === pos.y)) {
                const itemTypes = ['HEALTH', 'SWORD', 'SHIELD'];
                const type = itemTypes[Math.floor(Math.random() * itemTypes.length)];
                this.items.push(new Item(pos.x, pos.y, type));
            }
        }

        const stairsPos = this.map.getEmptyTile();
        this.stairs = { x: stairsPos.x, y: stairsPos.y, emoji: EMOJIS.STAIRS };

        this.map.computeFov(this.player.x, this.player.y, 8);
        this.isPlayerTurn = true;
    }

    handleInput(e) {
        if (this.gameState === GameState.PLAYING) {
            if (!this.isPlayerTurn || this.isAnimating) return;
            
            let dx = 0, dy = 0;
            switch (e.key) {
                case 'ArrowUp': case 'w': dy = -1; break;
                case 'ArrowDown': case 's': dy = 1; break;
                case 'ArrowLeft': case 'a': dx = -1; break;
                case 'ArrowRight': case 'd': dx = 1; break;
                default: return;
            }

            e.preventDefault();
            this.movePlayer(dx, dy);
        } else if (this.gameState === GameState.START_SCREEN || this.gameState === GameState.GAME_OVER) {
            if (e.key === 'Enter') {
                if (this.audioEngine.audioContext.state === 'suspended') {
                    this.audioEngine.audioContext.resume();
                }
                this.startGame();
            }
        }
    }

    movePlayer(dx, dy) {
        const newX = this.player.x + dx;
        const newY = this.player.y + dy;

        if (this.map.isWall(newX, newY)) return;

        const targetEntity = this.getEntityAt(newX, newY);
        if (targetEntity && targetEntity !== this.player) {
            this.attack(this.player, targetEntity);
        } else {
            this.player.x = newX;
            this.player.y = newY;
            this.audioEngine.play('move');
        }
        
        this.isPlayerTurn = false;
        this.map.computeFov(this.player.x, this.player.y, 8);
        this.checkItems();
        this.checkStairs();
    }
    
    attack(attacker, defender) {
        const damage = Math.max(1, attacker.atk - defender.def);
        defender.hp -= damage;
        
        const defenderPos = {x: defender.animX + TILE_SIZE/2, y: defender.animY + TILE_SIZE/2};
        this.particleSystem.emit(defenderPos.x, defenderPos.y, '#f00', 15, 4, 3, 20);

        if (attacker === this.player) {
            this.audioEngine.play('hit');
            this.addMessage(`You hit the ${defender.name} for ${damage} damage!`, '#fff');
        } else {
            this.audioEngine.play('enemyHit');
            this.screenShake = 10;
            this.addMessage(`${attacker.name} hits you for ${damage} damage!`, '#f55');
        }

        if (defender.hp <= 0) {
            if (defender === this.player) {
                this.gameState = GameState.GAME_OVER;
                this.audioEngine.play('gameOver');
            } else {
                this.addMessage(`You defeated the ${defender.name}!`, '#0f0');
                this.entities = this.entities.filter(e => e !== defender);
            }
        }
    }

    checkItems() {
        const itemIndex = this.items.findIndex(item => item.x === this.player.x && item.y === this.player.y);
        if (itemIndex > -1) {
            const item = this.items[itemIndex];
            this.applyItem(item);
            this.items.splice(itemIndex, 1);
            this.audioEngine.play('pickup');
            this.particleSystem.emit(this.player.animX + TILE_SIZE/2, this.player.animY + TILE_SIZE/2, '#ff0', 20, 5, 4, 30);
        }
    }

    applyItem(item) {
        switch(item.type) {
            case 'HEALTH':
                this.player.heal(10);
                this.addMessage("You found a Health Potion! +10 HP", '#f88');
                break;
            case 'SWORD':
                this.player.atk += 2;
                this.addMessage("You found a Sword! ATK +2", '#88f');
                break;
            case 'SHIELD':
                this.player.def += 1;
                this.addMessage("You found a Shield! DEF +1", '#8f8');
                break;
        }
    }

    checkStairs() {
        if (this.player.x === this.stairs.x && this.player.y === this.stairs.y) {
            this.floor++;
            this.addMessage(`You descend to floor ${this.floor}...`, '#0ff');
            this.audioEngine.play('descend');
            this.generateLevel();
        }
    }

    enemyTurn() {
        for (const entity of this.entities) {
            if (entity instanceof Enemy) {
                const dx = this.player.x - entity.x;
                const dy = this.player.y - entity.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (this.map.visible[entity.y][entity.x]) {
                     if (distance < 1.5) {
                        this.attack(entity, this.player);
                    } else {
                        // Simple pathfinding: move towards player
                        let moveX = 0;
                        let moveY = 0;
                        if (Math.abs(dx) > Math.abs(dy)) {
                            moveX = Math.sign(dx);
                        } else {
                            moveY = Math.sign(dy);
                        }
                        
                        const newX = entity.x + moveX;
                        const newY = entity.y + moveY;
                        
                        if (!this.map.isWall(newX, newY) && !this.getEntityAt(newX, newY)) {
                            entity.x = newX;
                            entity.y = newY;
                        }
                    }
                }
            }
        }
    }
    
    addMessage(text, color) {
        this.messages.unshift({text, color, alpha: 1.0});
        if (this.messages.length > 5) {
            this.messages.pop();
        }
    }

    getEntityAt(x, y) {
        return this.entities.find(e => e.x === x && e.y === y);
    }
    
    update(deltaTime) {
        if (this.screenShake > 0) {
            this.screenShake--;
        }

        this.particleSystem.update();

        this.isAnimating = false;
        [...this.entities, ...this.items].forEach(e => {
            e.updateAnimation();
            if (e.isAnimating) this.isAnimating = true;
        });

        if (this.gameState === GameState.PLAYING && !this.isPlayerTurn && !this.isAnimating) {
            this.enemyTurn();
            this.isPlayerTurn = true;
        }
        
        // Update message visibility
        this.messages.forEach(msg => {
            if (msg.alpha > 0) msg.alpha -= 0.005;
        });
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Apply screen shake
        if (this.screenShake > 0) {
            const shakeX = (Math.random() - 0.5) * this.screenShake;
            const shakeY = (Math.random() - 0.5) * this.screenShake;
            this.ctx.translate(shakeX, shakeY);
        }

        switch(this.gameState) {
            case GameState.START_SCREEN:
                this.drawStartScreen();
                break;
            case GameState.PLAYING:
                this.drawGame();
                break;
            case GameState.GAME_OVER:
                this.drawGameOverScreen();
                break;
        }

        if (this.screenShake > 0) {
            this.ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
        }
    }

    drawGame() {
        this.map.draw(this.ctx, TILE_SIZE);
        
        // Draw stairs
        if (this.map.visible[this.stairs.y][this.stairs.x]) {
            this.ctx.font = `${TILE_SIZE * 0.8}px monospace`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillText(this.stairs.emoji, this.stairs.x * TILE_SIZE + TILE_SIZE / 2, this.stairs.y * TILE_SIZE + TILE_SIZE / 2);
        }

        // Draw items
        this.items.forEach(item => {
            if (this.map.visible[item.y][item.x]) {
                item.draw(this.ctx, TILE_SIZE);
            }
        });

        // Draw entities
        this.entities.sort((a,b) => a === this.player ? 1 : -1).forEach(entity => {
            if (this.map.visible[entity.y][entity.x]) {
                entity.draw(this.ctx, TILE_SIZE);
            }
        });

        this.particleSystem.draw(this.ctx);
        this.drawUI();
    }
    
    drawUI() {
        // Stats
        this.ctx.fillStyle = COLORS.UI_BG;
        this.ctx.fillRect(5, 5, 250, 80);
        this.ctx.font = '16px monospace';
        this.ctx.fillStyle = COLORS.UI_TEXT;
        this.ctx.textAlign = 'left';
        this.ctx.textBaseline = 'top';
        this.ctx.fillText(`Floor: ${this.floor}`, 15, 15);
        this.ctx.fillText(`${EMOJIS.ITEMS.HEALTH} HP: ${this.player.hp}/${this.player.maxHp}`, 15, 35);
        this.ctx.fillText(`⚔️ ATK: ${this.player.atk}  🛡️ DEF: ${this.player.def}`, 15, 55);

        // Messages
        this.messages.forEach((msg, index) => {
            this.ctx.globalAlpha = msg.alpha;
            this.ctx.fillStyle = msg.color;
            this.ctx.fillText(msg.text, 15, this.canvas.height - 25 * (index + 1));
        });
        this.ctx.globalAlpha = 1.0;
    }

    drawStartScreen() {
        this.drawGradientBackground();
        this.ctx.fillStyle = '#fff';
        this.ctx.font = 'bold 72px monospace';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('Spire Scramble', this.canvas.width / 2, this.canvas.height / 3);

        this.ctx.font = '24px monospace';
        this.ctx.fillText('Descend the spire. Defeat monsters.', this.canvas.width / 2, this.canvas.height / 2);
        this.ctx.fillText('Controls: Arrow Keys or WASD to move', this.canvas.width / 2, this.canvas.height / 2 + 40);

        this.ctx.fillStyle = '#0ff';
        this.ctx.font = '32px monospace';
        this.ctx.fillText('Press [Enter] to Start', this.canvas.width / 2, this.canvas.height * 0.75);
    }

    drawGameOverScreen() {
        this.drawGradientBackground();
        this.ctx.fillStyle = '#f00';
        this.ctx.font = 'bold 72px monospace';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 3);

        this.ctx.fillStyle = '#fff';
        this.ctx.font = '32px monospace';
        this.ctx.fillText(`You reached floor ${this.floor}`, this.canvas.width / 2, this.canvas.height / 2);

        this.ctx.fillStyle = '#0ff';
        this.ctx.font = '32px monospace';
        this.ctx.fillText('Press [Enter] to Restart', this.canvas.width / 2, this.canvas.height * 0.75);
    }
    
    drawGradientBackground() {
        const gradient = this.ctx.createRadialGradient(
            this.canvas.width / 2, this.canvas.height / 2, 0,
            this.canvas.width / 2, this.canvas.height / 2, this.canvas.width / 1.5
        );
        gradient.addColorStop(0, '#334');
        gradient.addColorStop(1, '#112');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    gameLoop(timestamp) {
        const deltaTime = timestamp - this.lastTime;
        this.lastTime = timestamp;

        this.update(deltaTime);
        this.draw();

        requestAnimationFrame((t) => this.gameLoop(t));
    }
}

// =============================================================================
// INITIALIZE GAME
// =============================================================================
window.onload = () => {
    const game = new Game(canvas);
};

</script>
</body>
</html>